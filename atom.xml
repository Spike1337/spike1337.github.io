<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spike&#39;s Blog</title>
  
  
  <link href="https://spike1337.github.io/atom.xml" rel="self"/>
  
  <link href="https://spike1337.github.io/"/>
  <updated>2023-07-25T07:45:27.475Z</updated>
  <id>https://spike1337.github.io/</id>
  
  <author>
    <name>Spike</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言 · statx</title>
    <link href="https://spike1337.github.io/2023/07/25/statx/"/>
    <id>https://spike1337.github.io/2023/07/25/statx/</id>
    <published>2023-07-25T06:41:21.000Z</published>
    <updated>2023-07-25T07:45:27.475Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发遇到一个问题，想要获取某个文件毫秒级的修改时间。众所周知C标准库中提供的<code>stat</code>函数只能获取到秒级的修改时间<code>st_mtime</code>。相关的信息翻了个遍，最终还是神奇的ChatGPT给我了答案：</p><p>Linux 4.11及更高版本，支持<code>statx</code>提供了毫秒级的文件修改时间</p><h2 id="SYNOPSIS">SYNOPSIS</h2><p><strong>Struct</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">statx</span> &#123;</span><br><span class="line">    __u32 stx_mask;        <span class="comment">/* Mask of bits indicating</span></span><br><span class="line"><span class="comment">                                filled fields */</span></span><br><span class="line">    __u32 stx_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">    __u64 stx_attributes;  <span class="comment">/* Extra file attribute indicators */</span></span><br><span class="line">    __u32 stx_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">    __u32 stx_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">    __u32 stx_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    __u16 stx_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">    __u64 stx_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">    __u64 stx_size;        <span class="comment">/* Total size in bytes */</span></span><br><span class="line">    __u64 stx_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line">    __u64 stx_attributes_mask;</span><br><span class="line">                            <span class="comment">/* Mask to show what&#x27;s supported</span></span><br><span class="line"><span class="comment">                                in stx_attributes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields are file timestamps */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">statx_timestamp</span> stx_atime;  <span class="comment">/* Last access */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">statx_timestamp</span> stx_btime;  <span class="comment">/* Creation */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">statx_timestamp</span> stx_ctime;  <span class="comment">/* Last status change */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">statx_timestamp</span> stx_mtime;  <span class="comment">/* Last modification */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this file represents a device, then the next two</span></span><br><span class="line"><span class="comment">        fields contain the ID of the device */</span></span><br><span class="line">    __u32 stx_rdev_major;  <span class="comment">/* Major ID */</span></span><br><span class="line">    __u32 stx_rdev_minor;  <span class="comment">/* Minor ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The next two fields contain the ID of the device</span></span><br><span class="line"><span class="comment">        containing the filesystem where the file resides */</span></span><br><span class="line">    __u32 stx_dev_major;   <span class="comment">/* Major ID */</span></span><br><span class="line">    __u32 stx_dev_minor;   <span class="comment">/* Minor ID */</span></span><br><span class="line"></span><br><span class="line">    __u64 stx_mnt_id;      <span class="comment">/* Mount ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Direct I/O alignment restrictions */</span></span><br><span class="line">    __u32 stx_dio_mem_align;</span><br><span class="line">    __u32 stx_dio_offset_align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中四个<code>statx_timestamp</code>就是我们需要的毫秒级时间戳</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">statx_timestamp</span> &#123;</span><br><span class="line">    __s64   tv_sec;      <span class="comment">// 秒数时间戳</span></span><br><span class="line">    __u32   tv_nsec;     <span class="comment">// tv_srchi周的纳秒数</span></span><br><span class="line">    __s32   __reserved;  <span class="comment">// 保留精度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>FUNCTION</strong></p><p>函数statx位于C标准库 Standard C library (libc, -lc)，函数的声明和使用如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">statx</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *restrict pathname, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">unsigned</span> <span class="type">int</span> mask, <span class="keyword">struct</span> statx *restrict statxbuf)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>RETURN</strong></p><p>如果执行成功，返回0，否则返回-1并设置errno</p><p>更详细的函数信息请阅读 <a href="https://man7.org/linux/man-pages/man2/statx.2.html">LINUX MANUAL PAGE</a></p><h2 id="Example">Example</h2><p>我自己测试的一个简单例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;tmp_file&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// statx 结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">statx</span> buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AT_FDCWD    在当前目录下运行</span></span><br><span class="line">    <span class="comment">// STATX_MTIME 获取修改时间</span></span><br><span class="line">    <span class="comment">// AT_SYMLINK_NOFOLLOW 如果是链接则返回链接本身信息</span></span><br><span class="line">    <span class="type">int</span> result =</span><br><span class="line">        <span class="built_in">statx</span>(AT_FDCWD, filename, AT_SYMLINK_NOFOLLOW, STATX_MTIME, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: %m\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer.stx_mtime 记录文件的最后修改时间</span></span><br><span class="line">    <span class="comment">// tv_sec 是秒级, tv_nsec 是毫秒级</span></span><br><span class="line">    <span class="type">int64_t</span> sec = buffer.stx_mtime.tv_sec;</span><br><span class="line">    <span class="type">int</span>     micro_sec = buffer.stx_mtime.tv_nsec / <span class="number">1000</span>;</span><br><span class="line">    <span class="type">char</span>    time_str[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strftime</span>(time_str, <span class="number">128</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, <span class="built_in">localtime</span>(&amp;sec));</span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Modification time of file %s is %s.%d\n&quot;</span>, filename,</span><br><span class="line">        time_str, micro_sec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux测试用例</p><p><a href="https://kgithub.com/torvalds/linux/blob/master/samples/vfs/test-statx.c">https://kgithub.com/torvalds/linux/blob/master/samples/vfs/test-statx.c</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开发遇到一个问题，想要获取某个文件毫秒级的修改时间。众所周知C标准库中提供的&lt;code&gt;stat&lt;/code&gt;函数只能获取到秒级的修改时间&lt;code&gt;st_mtime&lt;/code&gt;。相关的信息翻了个遍，最终还是神奇的ChatGPT给我了答案：&lt;/p&gt;
&lt;p&gt;Linux </summary>
      
    
    
    
    <category term="Linux" scheme="https://spike1337.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://spike1337.github.io/tags/Linux/"/>
    
    <category term="libc" scheme="https://spike1337.github.io/tags/libc/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL源码 · 元组管理（三）· 元组的插入</title>
    <link href="https://spike1337.github.io/2023/07/13/tuple_insert/"/>
    <id>https://spike1337.github.io/2023/07/13/tuple_insert/</id>
    <published>2023-07-13T11:02:08.000Z</published>
    <updated>2023-07-18T09:50:24.183Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%85%83%E7%BB%84%E6%8F%92%E5%85%A5">元组插入</a><ul><li><a href="#%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%83%E7%BB%84%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE">一、初始化元组的元数据</a></li><li><a href="#%E4%BA%8C%E8%8E%B7%E5%8F%96%E5%8F%AF%E7%94%A8%E7%9A%84page">二、获取可用的page</a></li><li><a href="#%E4%B8%89%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE">三、写入数据</a></li><li><a href="#%E5%9B%9Bwal-log%E5%92%8C%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF">四、WAL log和统计信息</a></li></ul></li></ul><hr><br><h2 id="元组插入">元组插入</h2><p>元组的插入主要由函数<code>heap_insert</code>来完成，主要分为几步：</p><ol><li>初始化元组头 HeapTupleHeader</li><li>获取可用的page</li><li>判断元组可见性和事务冲突</li><li>将元组写入可用的page，并标记page dirty</li><li>写wal</li></ol><h3 id="一、初始化元组的元数据">一、初始化元组的元数据</h3><p>在<code>heap_prepare_insert</code>中完成，接口比较简单，我们直接来看源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> HeapTuple</span></span><br><span class="line"><span class="function"><span class="title">heap_prepare_insert</span><span class="params">(Relation relation, HeapTuple tup, TransactionId xid,</span></span></span><br><span class="line"><span class="params"><span class="function">                    CommandId cid, <span class="type">int</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 计算元组的infomask &amp; infomask2 */</span></span><br><span class="line">    tup-&gt;t_data-&gt;t_infomask &amp;= ~(HEAP_XACT_MASK);</span><br><span class="line">    tup-&gt;t_data-&gt;t_infomask2 &amp;= ~(HEAP2_XACT_MASK);</span><br><span class="line">    tup-&gt;t_data-&gt;t_infomask |= HEAP_XMAX_INVALID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置xmin，也就是元组插入的事务号 */</span></span><br><span class="line">    <span class="built_in">HeapTupleHeaderSetXmin</span>(tup-&gt;t_data, xid);</span><br><span class="line">    <span class="keyword">if</span> (options &amp; HEAP_INSERT_FROZEN)</span><br><span class="line">        <span class="built_in">HeapTupleHeaderSetXminFrozen</span>(tup-&gt;t_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置cid、xmax和tableoid，由于是元组插入，则将xmax设置为0 */</span></span><br><span class="line">    <span class="built_in">HeapTupleHeaderSetCmin</span>(tup-&gt;t_data, cid);</span><br><span class="line">    <span class="built_in">HeapTupleHeaderSetXmax</span>(tup-&gt;t_data, <span class="number">0</span>);</span><br><span class="line">    tup-&gt;t_tableOid = <span class="built_in">RelationGetRelid</span>(relation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断是否为TOAST元组 */</span></span><br><span class="line">    <span class="keyword">if</span> (relation-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;</span><br><span class="line">        relation-&gt;rd_rel-&gt;relkind != RELKIND_MATVIEW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Assert</span>(!<span class="built_in">HeapTupleHasExternal</span>(tup));</span><br><span class="line">        <span class="keyword">return</span> tup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">HeapTupleHasExternal</span>(tup) || tup-&gt;t_len &gt; TOAST_TUPLE_THRESHOLD)</span><br><span class="line">        <span class="comment">/* TOAST元组，调用相应的插入接口 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">heap_toast_insert_or_update</span>(relation, tup, <span class="literal">NULL</span>, options);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* 否则直接返回准备好的tup */</span></span><br><span class="line">        <span class="keyword">return</span> tup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、获取可用的page">二、获取可用的page</h3><p>在<code>RelationGetBufferForTuple</code>中完成。</p><p>relation是目标表对象，len是tuple插入需要的长度。otherBuffer用于元组update时替换旧的buffer，options是写入的选项，bistate表示批量插入对象的状态，vmbuffer和vmbuffer_other用于可见性映射</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Buffer</span></span><br><span class="line"><span class="function"><span class="title">RelationGetBufferForTuple</span><span class="params">(Relation relation, Size len,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Buffer otherBuffer, <span class="type">int</span> options,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BulkInsertState bistate,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Buffer *vmbuffer, Buffer *vmbuffer_other)</span></span></span><br></pre></td></tr></table></figure><ol><li>通过填充因子，计算空闲空间。</li></ol><p>填充因子<code>FillFactor</code>是一个百分比，限制了我们对于page的使用率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用了默认填充百分比, HEAP_DEFAULT_FILLFACTOR = 100, 也就是完全填充</span></span><br><span class="line">saveFreeSpace = <span class="built_in">RelationGetTargetPageFreeSpace</span>(relation, HEAP_DEFAULT_FILLFACTOR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有tuple的page中也可能有line pointer，所以使用一个近似值</span></span><br><span class="line">nearlyEmptyFreeSpace = MaxHeapTupleSize -</span><br><span class="line">    (MaxHeapTuplesPerPage / <span class="number">8</span> * <span class="built_in">sizeof</span>(ItemIdData));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len + saveFreeSpace &gt; nearlyEmptyFreeSpace)</span><br><span class="line">    targetFreeSpace = <span class="built_in">Max</span>(len, nearlyEmptyFreeSpace);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    targetFreeSpace = len + saveFreeSpace;</span><br></pre></td></tr></table></figure><ol start="2"><li>尝试从cache中获取表最近使用的page，如果没有则尝试通过FSM获取满足插入条件的page</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bistate &amp;&amp; bistate-&gt;current_buf != InvalidBuffer)</span><br><span class="line">    targetBlock = <span class="built_in">BufferGetBlockNumber</span>(bistate-&gt;current_buf);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    targetBlock = <span class="built_in">RelationGetTargetBlock</span>(relation);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (targetBlock == InvalidBlockNumber &amp;&amp; use_fsm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// cache中没有目标page，让FSM来提供一个初始目标page</span></span><br><span class="line">    targetBlock = <span class="built_in">GetPageWithFreeSpace</span>(relation, targetFreeSpace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>接下来我们拿着之前获取到的block，去获取对应的buffer</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherBuffer == InvalidBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有otherbuffer, 简单插入语句, 获取buffer</span></span><br><span class="line">    buffer = <span class="built_in">ReadBufferBI</span>(relation, targetBlock, RBM_NORMAL, bistate);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PageIsAllVisible</span>(<span class="built_in">BufferGetPage</span>(buffer)))</span><br><span class="line">        <span class="built_in">visibilitymap_pin</span>(relation, targetBlock, vmbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((options &amp; HEAP_INSERT_FROZEN) &amp;&amp;</span><br><span class="line">        (<span class="built_in">PageGetMaxOffsetNumber</span>(<span class="built_in">BufferGetPage</span>(buffer)) == <span class="number">0</span>))</span><br><span class="line">        <span class="built_in">visibilitymap_pin</span>(relation, targetBlock, vmbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LockBuffer</span>(buffer, BUFFER_LOCK_EXCLUSIVE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page = <span class="built_in">BufferGetPage</span>(buffer);</span><br></pre></td></tr></table></figure><ul><li>如果拿到的page有足够的空闲空间，我们就完成了获取可用page的步骤，直接返回就可以了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查page是否有足够的空闲空间，如果有则返回当前page</span></span><br><span class="line">pageFreeSpace = <span class="built_in">PageGetHeapFreeSpace</span>(page);</span><br><span class="line"><span class="keyword">if</span> (targetFreeSpace &lt;= pageFreeSpace)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* use this page as future insert target, too */</span></span><br><span class="line">    <span class="built_in">RelationSetTargetBlock</span>(relation, targetBlock);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果没有足够的空间，我们需要去寻找下一个block</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有正在进行的批量操作, 则还有其他的未使用的page, 我们尝试使用下一个page</span></span><br><span class="line"><span class="keyword">if</span> (bistate &amp;&amp; bistate-&gt;next_free != InvalidBlockNumber)</span><br><span class="line">&#123;</span><br><span class="line">    targetBlock = bistate-&gt;next_free;</span><br><span class="line">    <span class="keyword">if</span> (bistate-&gt;next_free &gt;= bistate-&gt;last_free)</span><br><span class="line">    &#123;</span><br><span class="line">        bistate-&gt;next_free = InvalidBlockNumber;</span><br><span class="line">        bistate-&gt;last_free = InvalidBlockNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        bistate-&gt;next_free++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有进行批量操作, 这个时候就要问一问FSM的意见</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!use_fsm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有FSM, 只能跳出循环去扩页</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过FSM寻找下一个合适的page</span></span><br><span class="line">    targetBlock = <span class="built_in">RecordAndGetPageWithFreeSpace</span>(relation,</span><br><span class="line">                                                targetBlock,</span><br><span class="line">                                                pageFreeSpace,</span><br><span class="line">                                                targetFreeSpace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果以上循环中没有找到空闲buffer，我们只能进入扩页的逻辑来新增一个page用来插入</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩页并返回新增的page, 扩页的具体逻辑我们在这就不详细介绍了</span></span><br><span class="line"><span class="comment">// 简单来说就是给relation加Exclusive锁, 然后初始化一个新的page进去</span></span><br><span class="line">buffer = <span class="built_in">RelationAddBlocks</span>(relation, bistate, num_pages, use_fsm,</span><br><span class="line">                           &amp;unlockedTargetBuffer);</span><br><span class="line"></span><br><span class="line">targetBlock = <span class="built_in">BufferGetBlockNumber</span>(buffer);</span><br><span class="line">page = <span class="built_in">BufferGetPage</span>(buffer);</span><br></pre></td></tr></table></figure><ol start="5"><li>新增的页我们再来检查下是否有足够的空闲空间，如果有的话就能返回使用了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pageFreeSpace = <span class="built_in">PageGetHeapFreeSpace</span>(page);</span><br><span class="line"><span class="keyword">if</span> (len &gt; pageFreeSpace)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlockedTargetBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (otherBuffer != InvalidBuffer)</span><br><span class="line">            <span class="built_in">LockBuffer</span>(otherBuffer, BUFFER_LOCK_UNLOCK);</span><br><span class="line">        <span class="built_in">UnlockReleaseBuffer</span>(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">elog</span>(PANIC, <span class="string">&quot;tuple is too big: size %zu&quot;</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RelationSetTargetBlock</span>(relation, targetBlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buffer;</span><br></pre></td></tr></table></figure><h3 id="三、写入数据">三、写入数据</h3><p>写入数据是由接口<code>RelationPutHeapTuple</code>来完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">RelationPutHeapTuple</span><span class="params">(Relation relation,</span></span></span><br><span class="line"><span class="params"><span class="function">                     Buffer buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                     HeapTuple tuple,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">bool</span> token)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Page        pageHeader;</span><br><span class="line">    OffsetNumber offnum;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    pageHeader = <span class="built_in">BufferGetPage</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元组插入到page中</span></span><br><span class="line">    offnum = <span class="built_in">PageAddItem</span>(pageHeader, (Item) tuple-&gt;t_data,</span><br><span class="line">                            tuple-&gt;t_len, InvalidOffsetNumber, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前的位置到元组的t_self中</span></span><br><span class="line">    <span class="built_in">ItemPointerSet</span>(&amp;(tuple-&gt;t_self), <span class="built_in">BufferGetBlockNumber</span>(buffer), offnum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前的位置也记录到元组的ctid中</span></span><br><span class="line">    <span class="keyword">if</span> (!token)</span><br><span class="line">    &#123;</span><br><span class="line">        ItemId        itemId = <span class="built_in">PageGetItemId</span>(pageHeader, offnum);</span><br><span class="line">        HeapTupleHeader item = (HeapTupleHeader) <span class="built_in">PageGetItem</span>(pageHeader, itemId);</span><br><span class="line"></span><br><span class="line">        item-&gt;t_ctid = tuple-&gt;t_self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要的工作都有函数<code>PageAddItem</code>来完成，<code>PageAddItem</code>是一个宏，内部调用<code>PageAddItemExtended</code>，我们来详细看下这个接口</p><p>page是插入的页面，item的插入的数据指针，size的插入数据的大小。offsetNumber是元组在页面中的偏移量，如果插入成功则会被返回。flags是插入的选项</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OffsetNumber</span></span><br><span class="line"><span class="function"><span class="title">PageAddItemExtended</span><span class="params">(Page page,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Item item,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Size size,</span></span></span><br><span class="line"><span class="params"><span class="function">                    OffsetNumber offsetNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> flags)</span></span></span><br></pre></td></tr></table></figure><ol><li>首先我们在page中寻找下一个slot的位置，如果之后没有找到空余的slot，我们就会使用这个位置来插入元组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">limit = <span class="built_in">OffsetNumberNext</span>(<span class="built_in">PageGetMaxOffsetNumber</span>(page));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果page有free line pointer, 也就是pd_flags中包含PD_HAS_FREE_LINES标记</span></span><br><span class="line"><span class="comment">// 则去行指针数组中寻找free slot</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">PageHasFreeLinePointers</span>(page))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 扫描PageHeader的行指针数组，查找标记为 LP_UNUSED的 itemId</span></span><br><span class="line">    <span class="keyword">for</span> (offsetNumber = FirstOffsetNumber;</span><br><span class="line">            offsetNumber &lt; limit;</span><br><span class="line">            offsetNumber++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ItemIdIsUsed</span>(itemId) &amp;&amp; !<span class="built_in">ItemIdHasStorage</span>(itemId))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有free line pointer, 使用limit</span></span><br><span class="line">    offsetNumber = limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>接下来我们计算page的pd_lower和pg_upper指针指向的offset</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (offsetNumber == limit || needshuffle)</span><br><span class="line">    lower = phdr-&gt;pd_lower + <span class="built_in">sizeof</span>(ItemIdData);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    lower = phdr-&gt;pd_lower;</span><br><span class="line"></span><br><span class="line">alignedSize = <span class="built_in">MAXALIGN</span>(size);</span><br><span class="line"></span><br><span class="line">upper = (<span class="type">int</span>) phdr-&gt;pd_upper - (<span class="type">int</span>) alignedSize;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后我们就可以把元组插入到page中了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果已经有了对应的行指针, 则重新设置行指针中的值和标记</span></span><br><span class="line">itemId = <span class="built_in">PageGetItemId</span>(page, offsetNumber);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needshuffle)</span><br><span class="line">    <span class="built_in">memmove</span>(itemId + <span class="number">1</span>, itemId,</span><br><span class="line">            (limit - offsetNumber) * <span class="built_in">sizeof</span>(ItemIdData));</span><br><span class="line"></span><br><span class="line"><span class="built_in">ItemIdSetNormal</span>(itemId, upper, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据插入到对应的offset</span></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">char</span> *) page + upper, item, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新PageHeader中的upper和lower指针</span></span><br><span class="line">phdr-&gt;pd_lower = (LocationIndex) lower;</span><br><span class="line">phdr-&gt;pd_upper = (LocationIndex) upper;</span><br></pre></td></tr></table></figure><h3 id="四、WAL-log和统计信息">四、WAL log和统计信息</h3><p>将元组真正插入到page之后，我们会写WAL log并更新相关的统计信息。这两块我们就不在这里详细的描述了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%83%E7%BB%84%E6%8F%92%E5%85%A5&quot;&gt;元组插入&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%83%E7%BB%84%</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/tags/PostgreSQL/"/>
    
    <category term="storage" scheme="https://spike1337.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL源码 · 元组管理（二）· 元组的组织结构</title>
    <link href="https://spike1337.github.io/2023/07/11/tuple_manager_2/"/>
    <id>https://spike1337.github.io/2023/07/11/tuple_manager_2/</id>
    <published>2023-07-11T10:35:06.000Z</published>
    <updated>2023-07-18T09:50:05.053Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#tuple%E7%9A%84%E7%BB%93%E6%9E%84">Tuple的结构</a><ul><li><a href="#heaptupleheader">HeapTupleHeader</a><ul><li><a href="#heaptuplefields">HeapTupleFields</a></li><li><a href="#datumtuplefields">DatumTupleFields</a></li></ul></li></ul></li></ul><hr><br><p>上次我们简单看了下PostgreSQL中页面的组织结构，介绍了PageHeader和行指针的结构。这次我们来看看元组的结构，也就是tuple的<code>成员变量</code></p><h2 id="Tuple的结构">Tuple的结构</h2><p>元组的结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint32          t_len;</span><br><span class="line">    ItemPointerData t_self;</span><br><span class="line">    Oid             t_tableOid;</span><br><span class="line">    HeapTupleHeader t_data;</span><br><span class="line">&#125; HeapTupleData;</span><br></pre></td></tr></table></figure><ul><li><code>t_len</code>，元组<code>t_data</code>字段的长度</li><li><code>t_self</code>，记录元组自己的位置信息，包括所在的block信息，和元组在页面中的offset</li><li><code>t_tableOid</code>，元组所在表的oid</li><li><code>t_data</code>，元组的元数据信息和具体存储的数据</li></ul><h3 id="HeapTupleHeader">HeapTupleHeader</h3><p>存储元组的元数据信息，结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        HeapTupleFields     t_heap;</span><br><span class="line">        DatumTupleFields    t_datum;</span><br><span class="line">    &#125; t_choice;</span><br><span class="line"></span><br><span class="line">    ItemPointerData t_ctid;</span><br><span class="line">    uint16      t_infomask2;</span><br><span class="line">    uint16      t_infomask;</span><br><span class="line">    uint8       t_hoff;</span><br><span class="line">    bits8       t_bits[FLEXIBLE_ARRAY_MEMBER];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>t_heap</code>，元组事务相关的域</li><li><code>t_datum</code>，元组数据相关的域</li><li><code>t_cid</code>，HOT元组会指向最新的元组位置，否则指向自己的位置</li><li><code>t_infomask2</code>，元组的属性数，和一些标记位</li><li><code>t_infomask</code>，元组的标记位。这些标记我们就不在这里介绍了</li><li><code>t_hoff</code>，header的整体大小</li><li><code>t_bits</code>，NULL值列的数组</li></ul><p><code>t_bits</code>数组之后存放的就是元组的数据</p><h4 id="HeapTupleFields">HeapTupleFields</h4><p>元组事务相关的域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleFields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TransactionId t_xmin;</span><br><span class="line">    TransactionId t_xmax;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        CommandId       t_cid;</span><br><span class="line">        TransactionId   t_xvac;</span><br><span class="line">    &#125; t_field3;</span><br><span class="line">&#125; HeapTupleFields;</span><br></pre></td></tr></table></figure><ul><li><code>t_xmin</code>，元组插入的事务号</li><li><code>t_xmax</code>，元组删除的事务号</li><li><code>t_cid</code>，命令id，表示当前事务中执行的修改该元组的命令的id</li><li><code>t_xvac</code>，vacuum full操作的事务号</li></ul><h4 id="DatumTupleFields">DatumTupleFields</h4><p>元组数据相关的域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DatumTupleFields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    int32datum_len_;<span class="comment">/* varlena header (do not touch directly!) */</span></span><br><span class="line">    int32datum_typmod;<span class="comment">/* -1, or identifier of a record type */</span></span><br><span class="line">    Oiddatum_typeid;<span class="comment">/* composite type OID, or RECORDOID */</span></span><br><span class="line"></span><br><span class="line">&#125; DatumTupleFields;</span><br></pre></td></tr></table></figure><ul><li><code>datum_len_</code>，变长数据类型的长度</li><li><code>datum_typmod</code>，数据类型</li><li><code>datum_typeid</code>，复合类型的类型oid</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#tuple%E7%9A%84%E7%BB%93%E6%9E%84&quot;&gt;Tuple的结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#heaptupleheader&quot;&gt;HeapTupleHeader&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/tags/PostgreSQL/"/>
    
    <category term="storage" scheme="https://spike1337.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL源码 · 元组管理（一）· 页的组织结构</title>
    <link href="https://spike1337.github.io/2023/07/10/tuple_manager_1/"/>
    <id>https://spike1337.github.io/2023/07/10/tuple_manager_1/</id>
    <published>2023-07-10T09:47:33.000Z</published>
    <updated>2023-07-18T09:50:01.929Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#page%E7%9A%84%E7%BB%93%E6%9E%84">Page的结构</a><ul><li><a href="#pageheader">PageHeader</a></li><li><a href="#%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%A1%8C%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84">页面的行指针结构</a></li></ul></li></ul><hr><br><p>开个新坑，简单写一写PostgreSQL中的元组管理。</p><p>对于整个存储架构，各种PostgreSQL的相关书籍已经介绍的很详细了，这里也就不再重复造轮子了。下面我们主要基于面向对象（大雾），来看看元组这个对象，有哪些<code>成员变量</code>，又有哪些<code>成员函数</code></p><hr><p>元组(Tuple)是PostgreSQL中数据的基本存储单元，Page又是存储元组的基本载体，所以这第一篇我们先来看一下Page的结构</p><h2 id="Page的结构">Page的结构</h2><p>Page的结构可以简单看下图所示</p><p><img src="/uploads/page_struct.png" alt="img"></p><p>page的默认大小为8k。每个页面的起始位置有大小为24个字节的PageHeader，记录该page相关的元数据信息。PageHeader中的pd_lower和pd_upper分别指向了页面空闲空间的首尾。</p><p>这里每一个tuple存储一条数据记录，从数据页底部开始向前依次存储。这些元组在页面中的位置存储在行指针line pointer中，每个行指针指向一个tuple。行指针从前向后依次存储，形成一个简单的数据。行指针中还存放了元组的状态和大小信息，扮演元组在页面中的索引的角色。行指针和tuple中间的部分为页面的空闲空间。</p><p>我们首先来看看PageHeader存储了什么元数据</p><h3 id="PageHeader">PageHeader</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PageXLogRecPtr  pd_lsn;</span><br><span class="line">    uint16          pd_checksum;</span><br><span class="line">    uint16          pd_flags;</span><br><span class="line">    LocationIndex   pd_lower;</span><br><span class="line">    LocationIndex   pd_upper;</span><br><span class="line">    LocationIndex   pd_special;</span><br><span class="line">    uint16          pd_pagesize_version;</span><br><span class="line">    TransactionId   pd_prune_xid;</span><br><span class="line">    ItemIdData      pd_linp[FLEXIBLE_ARRAY_MEMBER];</span><br><span class="line">&#125; PageHeaderData;</span><br></pre></td></tr></table></figure><ul><li><code>pd_lsn</code>，记录了该页面最后一次更改的WAL log的lsn</li><li><code>pg_checksum</code>，页面校验和</li><li><code>pd_flags</code>，页面的标记为，包括以下标记<ul><li><code>PD_HAS_FREE_LINES</code>，页面中是否有unused line pointer. 这个unused的概念我们之后在看到line pointer时会介绍</li><li><code>PD_PAGE_FULL</code>，页面是否有足够的空闲空间给新的tuple</li><li><code>PD_ALL_VISIBLE</code>，页面中的所有元组是否对<strong>当前和之后</strong>的所有事务可见</li></ul></li><li><code>pd_lower</code>，指向空闲空间的起始位置</li><li><code>pd_upper</code>，指向空闲空间的结束位置</li><li><code>pd_special</code>，指向特殊空间的起始位置</li><li><code>pd_pagesize_version</code>，页面布局的版本号</li><li><code>pd_prune_xid</code>，用于页面元组清理时的标记位，记录了最旧的可清理的事务号。没有则为0</li><li><code>pg_linp</code>，页面行指针数组</li></ul><h3 id="页面的行指针结构">页面的行指针结构</h3><p>行指针是一个32位大小的索引结构，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ItemIdData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span>    lp_off:<span class="number">15</span>,</span><br><span class="line">                lp_flags:<span class="number">2</span>,</span><br><span class="line">                lp_len:<span class="number">15</span>;</span><br><span class="line">&#125; ItemIdData;</span><br></pre></td></tr></table></figure><ul><li><code>lp_off</code>，记录了tuple在页面中的offset</li><li><code>lp_len</code>，记录了tuple的size</li><li><code>lp_flags</code>，是一个tuple状态的简单标记，方便在扫描元组时做一个初步筛选，有以下几个标记<ul><li><code>LP_UNUSED</code>，元组未使用，可以立刻被重用</li><li><code>LP_NORMAL</code>，元组状态正常</li><li><code>LP_REDIRECT</code>，元组被重定向了。用于PG的HOT链的头部和中间元组</li><li><code>LP_DEAD</code>，元组已死，但空间可能还没有回收</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#page%E7%9A%84%E7%BB%93%E6%9E%84&quot;&gt;Page的结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#pageheader&quot;&gt;PageHeader&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%A1%B5%E</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/tags/PostgreSQL/"/>
    
    <category term="storage" scheme="https://spike1337.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>Linux · 工具 · devtodo · 简洁的终端todo工具</title>
    <link href="https://spike1337.github.io/2023/02/07/devtodo-manual/"/>
    <id>https://spike1337.github.io/2023/02/07/devtodo-manual/</id>
    <published>2023-02-07T02:23:30.000Z</published>
    <updated>2023-07-18T09:49:29.766Z</updated>
    
    <content type="html"><![CDATA[<p>devtodo是一款运行于终端的todo工具，简洁是它的最大优势。devtodo 目前已被许多 Linux 发行版的软件仓库收录，可以从软件仓库中安装它，也可以从它的项目主页<a href="https://github.com/alecthomas/devtodo">devtodo</a>下载最新版本编译安装。</p><h2 id="快速上手">快速上手</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">todo          <span class="comment"># 显示 todo list</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tda           <span class="comment"># 添加一项 todo，也可以用 todo -a 命令</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tde  &lt;index&gt;  <span class="comment"># 修改第 index 条 todo</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tdd  &lt;index&gt;  <span class="comment"># 标记第 index 条 todo 已经完成</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tdr  &lt;index&gt;  <span class="comment"># 删除第 index 条 todo</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">todo -A       <span class="comment"># 显示所有的 todo 条目，包括完成的以及未完成的</span></span></span><br></pre></td></tr></table></figure><h2 id="命令展示">命令展示</h2><ul><li>todo</li></ul><p>显示todo list。按优先级顺序排列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">todo</span></span><br><span class="line"></span><br><span class="line">1.test 1</span><br><span class="line">2.test 2</span><br><span class="line">3.test 3</span><br><span class="line">4.test 4</span><br></pre></td></tr></table></figure><ul><li>tda</li></ul><p>添加一项todo。设定todo内容，并设置todo优先级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tda</span></span><br><span class="line"></span><br><span class="line">Enter text for the item you are adding.</span><br><span class="line"><span class="meta prompt_">text&gt; </span><span class="language-bash"><span class="built_in">test</span> 1</span></span><br><span class="line">1. veryhigh   2. high   3. medium   4. low   5. verylow</span><br><span class="line">Enter a priority from those listed above.</span><br><span class="line"><span class="meta prompt_">priority&gt; </span><span class="language-bash">1</span></span><br><span class="line">Index of new item is 1</span><br></pre></td></tr></table></figure><ul><li>tde k</li></ul><p>修改第 k 条 todo。可以重新编辑todo内容，并调整todo优先级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tde 1</span></span><br><span class="line"></span><br><span class="line">Modify the text of the item you are editing.</span><br><span class="line"><span class="meta prompt_">text&gt; </span><span class="language-bash"><span class="built_in">test</span> modify 1</span></span><br><span class="line">1. veryhigh   2. high   3. medium   4. low   5. verylow</span><br><span class="line">Enter a priority from those listed above.</span><br><span class="line"><span class="meta prompt_">priority&gt; </span><span class="language-bash">1</span></span><br></pre></td></tr></table></figure><ul><li>tdd k</li></ul><p>标记第 k 条 todo 已完成，可以设定完成的comment信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tdd 1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">comment&gt; </span><span class="language-bash"><span class="keyword">done</span></span></span><br></pre></td></tr></table></figure><ul><li>tdr k</li></ul><p>删除第 k 条 todo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tdr k</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>todo -A</li></ul><p>查看所有的 todo notes，不包括被删除项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 2.test 2</span><br><span class="line">  3.test 3</span><br><span class="line">  4.test 4</span><br></pre></td></tr></table></figure><h2 id="进阶配置">进阶配置</h2><ol><li>全局todo nots记录</li></ol><p>默认的devtodo是在执行<code>tda</code>时，在执行目录下创建文件<code>.todo</code>来记录todo notes，执行其他操作时也是读取执行目录下的<code>.todo</code>文件。也就是每个执行目录有自己的todo list。如果我们想要一个全局的todo list，我们需要使用<code>-G</code>参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-G, --global            Use the database specified by the --global-database option. Defaults to ~/.todo_global.</span><br></pre></td></tr></table></figure><p><code>-G</code>参数使用 <code>~/.todo_global</code>作为存储todo notes的数据库，这样我们的todo就可以在全局范围内使用。作为懒狗我就直接将<code>-G</code>参数写入了alias</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alias todo=&quot;todo -G&quot;</span><br><span class="line">alias tda=&quot;tda -G&quot;</span><br><span class="line">alias tdd=&quot;tdd -G&quot;</span><br><span class="line">alias tde=&quot;tde -G&quot;</span><br><span class="line">alias tdr=&quot;tdr -G&quot;</span><br></pre></td></tr></table></figure><p>当然，如果不想使用默认的<code>~/.todo_global</code>文件作为全局数据库，也可以通过<code>--global-database</code>指定全局数据库的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--global-database ARG   Specify the database to use if the -G (--global) parameter is used.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;devtodo是一款运行于终端的todo工具，简洁是它的最大优势。devtodo 目前已被许多 Linux 发行版的软件仓库收录，可以从软件仓库中安装它，也可以从它的项目主页&lt;a href=&quot;https://github.com/alecthomas/devtodo&quot;&gt;de</summary>
      
    
    
    
    <category term="Linux" scheme="https://spike1337.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://spike1337.github.io/tags/Linux/"/>
    
    <category term="tools" scheme="https://spike1337.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL · 源码解析 · MVCC机制</title>
    <link href="https://spike1337.github.io/2023/02/06/mvcc-source-code/"/>
    <id>https://spike1337.github.io/2023/02/06/mvcc-source-code/</id>
    <published>2023-02-06T06:36:45.000Z</published>
    <updated>2023-07-18T09:49:40.125Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务隔离级别</a><ul><li><a href="#%E6%A0%87%E5%87%86%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">标准事务隔离级别</a></li><li><a href="#postgresql%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">PostgreSQL的隔离级别</a></li></ul></li><li><a href="#mvcc%E6%9E%B6%E6%9E%84">MVCC架构</a><ul><li><a href="#%E5%85%83%E7%BB%84%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">元组相关数据结构</a></li><li><a href="#mvcc">MVCC</a><ul><li><a href="#mvcc%E4%B8%8E%E5%BF%AB%E7%85%A7">MVCC与快照</a></li></ul></li><li><a href="#mvcc%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0">MVCC机制的实现</a></li></ul></li></ul><hr><br><p>PostgreSQL采用多版本并发控制（MVCC）来维护数据的一致性。检索数据时，每个事务看到的都只是一段时间之前的数据快照。MVCC并不能解决所有的并发控制情况，需要使用传统数据库的锁机制来保证事务的并发，因此在PostgreSQL里也有表和行级别的锁定机制。此外PostgreSQL还提供了会话锁机制，可以利用它一次对某个对象加锁保证对于多个事务都有效。</p><h2 id="事务隔离级别">事务隔离级别</h2><h3 id="标准事务隔离级别">标准事务隔离级别</h3><p>三个必须在并行的事务之间避免的现象：</p><ul><li>脏读：一个事务读取了另一个未提交的并行事务写的数据</li><li>不可重复读：一个事务对一个数据前后读取两次，发现该数据已经被另一个已提交的数据修改过</li><li>幻读：事务A读取某一范围内的数据行时，事务B在该范围内插入新行，当事务A再次读取该范围内的数据时无法查询到新增的数据</li></ul><p>四个事务隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>⭕</td><td>⭕</td><td>⭕</td></tr><tr><td>读已提交</td><td>❌</td><td>⭕</td><td>⭕</td></tr><tr><td>可重复读</td><td>❌</td><td>❌</td><td>⭕</td></tr><tr><td>可串行化</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><h3 id="PostgreSQL的隔离级别">PostgreSQL的隔离级别</h3><p>在PostgreSQL中，可以请求以上四种事务隔离级别的任意一种。但是在内部，只有两种独立的隔离级别：读已提交和可串行化。即选择读未提交的隔离级别，实际用的是读已提交。下面介绍PostgreSQL定义的两种隔离级别：</p><ul><li><strong>读已提交</strong>：缺省隔离级别。当一个事务运行在这个隔离级别时，一个<code>SELECT</code>查询只能看到查询开始之前提交的数据。如果两个事务在对同一元组进行更新，如果第一个事务回滚，则忽略其作用，第二个事务继续更新该元组；第二个事务则等待第一个事务提交或回滚。如果第一个事务提交，系统重新计算查询条件，如果符合则继续更新操作。</li><li><strong>可串行化</strong>：提供了最严格的事务隔离。模拟串行的事务执行。如果两个事务在对同一元组进行更新，第二个事务则等待第一个事务提交或回滚。如果第一个事务回滚，则忽略其作用，第二个事务继续更新该元组；如果第一个事务提交，那么可串行化事务回滚，从头开始进行整个事务。</li></ul><p>在PostgreSQL系统中，事务的隔离级别所涉及的最小对象是元组，所以对元组的操作需要实施访问控制。这个操作是通过锁操作以及MVCC相关的操作来实现的</p><h2 id="MVCC架构">MVCC架构</h2><p>在内部，PostgreSQL利用多版本并发控制（MVCC，MultiVersion Concurrency Control）来维护数据的一致性。即当检索数据时，每个事务看到的只是一段时间之前的事务快照，而不是数据的当前状态。这样对每个数据库会话进行事务隔离，就可以避免一个事务看到其他并发时的更新导致不一致的数据</p><h3 id="元组相关数据结构">元组相关数据结构</h3><p>在PostgreSQL系统中，更新数据并不是用新值覆盖旧值，而是在表中开辟一片空间来存放新的元组，新值与旧值同时存在于数据库中，只是通过设置一些参数让系统可以识别他们</p><p>元组的事务和命令控制信息存储在<code>HeapTupleFields</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleFields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TransactionId t_xmin;<span class="comment">// 创建此tuple的XID</span></span><br><span class="line">    TransactionId t_xmax;<span class="comment">// 删除此tuple的XID</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        CommandIdt_cid;<span class="comment">// 创建或删除tuple的CID，也可能二者都保存</span></span><br><span class="line">        TransactionId t_xvac;<span class="comment">// 清理操作的事务ID</span></span><br><span class="line">    &#125;t_field3;</span><br><span class="line">&#125; HeapTupleFields;</span><br></pre></td></tr></table></figure><ul><li>如果一个事务确实创建并删除了同一个元组，则使用一个Combo Command ID 来保存Cmin和Cmax</li></ul><p>元组的相关控制信息存储在元组的头部<code>HeapTupleHeaderData</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">HeapTupleFields t_heap;</span><br><span class="line">DatumTupleFields t_datum;</span><br><span class="line">&#125;t_choice;</span><br><span class="line"></span><br><span class="line">ItemPointerData t_ctid;<span class="comment">// 本元组或更新元组的当前TID</span></span><br><span class="line">uint16t_infomask2;<span class="comment">// 属性、标记位数量标记位</span></span><br><span class="line">uint16t_infomask;<span class="comment">// 元组事务信息标记位</span></span><br><span class="line">uint8t_hoff;<span class="comment">// 头部长度</span></span><br><span class="line">bits8t_bits[FLEXIBLE_ARRAY_MEMBER];<span class="comment">// 标记作用的填充位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>其中，<code>t_ctid</code>当元组被保存在磁盘中时被初始化为自己的实际存储位置。如果元组被更新，<code>t_cid</code>指向更新后的新元组。如果要找到某个元组的最新版本，只需遍历由<code>t_ctid</code>构成的链表即可</li><li><code>t_infomask</code>字段表示当前元组的事务信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_HASNULL0x0001<span class="comment">// 空字段标记位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_HASVARWIDTH0x0002<span class="comment">// 变长字段标记位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_HASEXTERNAL0x0004<span class="comment">// 外部存储字段标记位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_HASOID_OLD0x0008<span class="comment">// 有OID字段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_KEYSHR_LOCK0x0010<span class="comment">// xmax是共享锁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_COMBOCID0x0020<span class="comment">// t_cid是combo cid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_EXCL_LOCK0x0040<span class="comment">// xmax是排他锁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_LOCK_ONLY0x0080<span class="comment">// xmax如果有效则只是一个锁</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// xmax is a shared locker</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_SHR_LOCK(HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_LOCK_MASK(HEAP_XMAX_SHR_LOCK | HEAP_XMAX_EXCL_LOCK | \</span></span><br><span class="line"><span class="meta"> HEAP_XMAX_KEYSHR_LOCK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMIN_COMMITTED0x0100<span class="comment">// t_xmin已提交</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMIN_INVALID0x0200<span class="comment">// t_xmin无效/中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMIN_FROZEN(HEAP_XMIN_COMMITTED|HEAP_XMIN_INVALID)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_COMMITTED0x0400<span class="comment">// t_xmax已提交</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_INVALID0x0800<span class="comment">// t_xmax无效/中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_IS_MULTI0x1000<span class="comment">// t_xmax是组合事务</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_UPDATED0x2000<span class="comment">// 更新后的新元组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MOVED_OFF0x4000<span class="comment">// 被之前版本的VACUUM FULL移到其他地方，用以兼容二进制升级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MOVED_IN0x8000<span class="comment">// 被之前版本的VACUUM FULL从其他地方移入，用以兼容二进制升级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MOVED (HEAP_MOVED_OFF | HEAP_MOVED_IN)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XACT_MASK0xFFF0<span class="comment">// 可见性相关标记</span></span></span><br></pre></td></tr></table></figure><h3 id="MVCC">MVCC</h3><p>MVCC基本原理如图。有两个并发事务T1，T2，T1将元组C更新为C‘，但并没有提交。此时T2要对该元组进行查询，会通过C和C’的头部信息的Xmin和Xmax以及t_infomask来判断哪个为对当前事务的有效版本</p><p><img src="/uploads/pg_mvcc_base.png" alt="MVCC基本原理"></p><h4 id="MVCC与快照">MVCC与快照</h4><p>讨论MVCC的判断逻辑之前，我们需要先了解快照（snapshot）</p><p>快照（snapshot）记录了数据库当前某个时刻的活跃事务列表，通过快照确定某个元组的版本对于当前快照是否可见。快照定义在<code>SnapshotData</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SnapshotData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SnapshotType snapshot_type; <span class="comment">// 快照类型</span></span><br><span class="line"></span><br><span class="line">    TransactionId xmin;         <span class="comment">// 所有XID &lt; xmin对当前快照可见</span></span><br><span class="line">    TransactionId xmax;         <span class="comment">// 所有XID &gt;= xmax对当前快照可见</span></span><br><span class="line"></span><br><span class="line">    TransactionId *xip;         <span class="comment">// 当前活跃事务的链表</span></span><br><span class="line">    uint32      xcnt;           <span class="comment">// 当前活跃事务链表长度</span></span><br><span class="line"></span><br><span class="line">    TransactionId *subxip;      <span class="comment">// 当前活跃子事务链表</span></span><br><span class="line">    int32       subxcnt;        <span class="comment">// 当前活跃子事务链表的长度</span></span><br><span class="line">    <span class="type">bool</span>        suboverflowed;  <span class="comment">// 活跃子事务数组是否移除</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span>        takenDuringRecovery;    <span class="comment">// 是否是在Recovery中的快照</span></span><br><span class="line">    <span class="type">bool</span>        copied;         <span class="comment">// 静态快照则为false</span></span><br><span class="line"></span><br><span class="line">    CommandId   curcid;         <span class="comment">// 所有CID &lt; curcid是可见的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HeapTupleSatisfiesDirty中的额外返回值，并没有在MVCC快照中使用</span></span><br><span class="line">    uint32      speculativeToken;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由快照管理器使用的信息</span></span><br><span class="line">    uint32      active_count;   <span class="comment">// 在活跃快照链表里的引用计数</span></span><br><span class="line">    uint32      regd_count;     <span class="comment">// 在已注册的快照链表里的引用计数</span></span><br><span class="line">    pairingheap_node ph_node;   <span class="comment">// 已注册的快照链表</span></span><br><span class="line"></span><br><span class="line">    TimestampTz whenTaken;      <span class="comment">// 记录快照的时间戳</span></span><br><span class="line">    XLogRecPtr  lsn;            <span class="comment">// 记录快照时在WAL中的位置</span></span><br><span class="line">&#125; SnapshotData;</span><br></pre></td></tr></table></figure><p>在PostgreSQL中有默认的7种形式快照（15.1），分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">SnapshotType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 元组对于给定的MVCC快照有效</span></span><br><span class="line">    SNAPSHOT_MVCC = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组对于自身有效</span></span><br><span class="line">    SNAPSHOT_SELF,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任何元组都是可见的</span></span><br><span class="line">    SNAPSHOT_ANY,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组作为TOAST行 有效</span></span><br><span class="line">    SNAPSHOT_TOAST,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面三个不太好解释，直接贴原文</span></span><br><span class="line">    <span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * A tuple is visible iff the tuple is valid including effects of open</span></span><br><span class="line"><span class="comment">     * transactions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here, we consider the effects of:</span></span><br><span class="line"><span class="comment">     * - all committed and in-progress transactions (as of the current instant)</span></span><br><span class="line"><span class="comment">     * - previous commands of this transaction</span></span><br><span class="line"><span class="comment">     * - changes made by the current command</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is essentially like SNAPSHOT_SELF as far as effects of the current</span></span><br><span class="line"><span class="comment">     * transaction and committed/aborted xacts are concerned.  However, it</span></span><br><span class="line"><span class="comment">     * also includes the effects of other xacts still in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A special hack is that when a snapshot of this type is used to</span></span><br><span class="line"><span class="comment">     * determine tuple visibility, the passed-in snapshot struct is used as an</span></span><br><span class="line"><span class="comment">     * output argument to return the xids of concurrent xacts that affected</span></span><br><span class="line"><span class="comment">     * the tuple.  snapshot-&gt;xmin is set to the tuple&#x27;s xmin if that is</span></span><br><span class="line"><span class="comment">     * another transaction that&#x27;s still in progress; or to</span></span><br><span class="line"><span class="comment">     * InvalidTransactionId if the tuple&#x27;s xmin is committed good, committed</span></span><br><span class="line"><span class="comment">     * dead, or my own xact.  Similarly for snapshot-&gt;xmax and the tuple&#x27;s</span></span><br><span class="line"><span class="comment">     * xmax.  If the tuple was inserted speculatively, meaning that the</span></span><br><span class="line"><span class="comment">     * inserter might still back down on the insertion without aborting the</span></span><br><span class="line"><span class="comment">     * whole transaction, the associated token is also returned in</span></span><br><span class="line"><span class="comment">     * snapshot-&gt;speculativeToken.  See also InitDirtySnapshot().</span></span><br><span class="line"><span class="comment">     * -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SNAPSHOT_DIRTY,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A tuple is visible iff it follows the rules of SNAPSHOT_MVCC, but</span></span><br><span class="line"><span class="comment">     * supports being called in timetravel context (for decoding catalog</span></span><br><span class="line"><span class="comment">     * contents in the context of logical decoding).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 元组对MVCC快照有效，且支持逻辑复制</span></span><br><span class="line">    SNAPSHOT_HISTORIC_MVCC,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A tuple is visible iff the tuple might be visible to some transaction;</span></span><br><span class="line"><span class="comment">     * false if it&#x27;s surely dead to everyone, i.e., vacuumable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For visibility checks snapshot-&gt;min must have been set up with the xmin</span></span><br><span class="line"><span class="comment">     * horizon to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 元组对某些事务可见，如果对所有事务都是dead tuple，也就是vacuumable，则返回false</span></span><br><span class="line">    SNAPSHOT_NON_VACUUMABLE</span><br><span class="line">&#125; SnapshotType;</span><br></pre></td></tr></table></figure><h3 id="MVCC机制的实现">MVCC机制的实现</h3><p>以函数<code>HeapTupleSatisfiesSelf</code>为例，下面介绍MVCC机制的具体实现。如果返回值为True，则该元组是可见的。判断时会考虑三个方面的因素：所有已提交的事务，当前事务前的所有命令以及当前命令前的所有操作。执行过程如下：</p><ul><li>检查Xmin是否为已提交，如果元组的Xmin还未提交</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xmin未提交</span></span><br><span class="line"><span class="keyword">if</span> (!HeapTupleHeaderXminCommitted(tuple))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Xmin无效，元组不可见</span></span><br><span class="line">    <span class="keyword">if</span> (HeapTupleHeaderXminInvalid(tuple))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容二进制升级</span></span><br><span class="line">    <span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_MOVED_OFF)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 兼容二进制升级</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_MOVED_IN)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Xmin为当前事务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Xmax无效，则XID无效，可见</span></span><br><span class="line">        <span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_INVALID)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Xmax被锁定，即元组被锁定，可见</span></span><br><span class="line">        <span class="keyword">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Xmax是组合事务</span></span><br><span class="line">        <span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI)</span><br><span class="line">        &#123;</span><br><span class="line">            xmax = HeapTupleGetUpdateXid(tuple);</span><br><span class="line">            <span class="comment">// 更新子事务必须已回滚，因为前提是Xmin未提交</span></span><br><span class="line">            <span class="keyword">if</span> (!TransactionIdIsCurrentTransactionId(xmax))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Xmax为当前事务</span></span><br><span class="line">        <span class="keyword">if</span> (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 删除子事务必须已终止</span></span><br><span class="line">            SetHintBits(tuple, buffer, HEAP_XMAX_INVALID,</span><br><span class="line">                        InvalidTransactionId);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Xmin正在某个后端进程中运行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Xmin已经被提交</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))</span><br><span class="line">        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,</span><br><span class="line">                    HeapTupleHeaderGetRawXmin(tuple));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 否则一定是中止或崩溃</span></span><br><span class="line">        SetHintBits(tuple, buffer, HEAP_XMIN_INVALID,</span><br><span class="line">                    InvalidTransactionId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Xmin已提交。如果Xmax无效或中断，元组可见</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_INVALID)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>Xmin已提交，Xmax已提交</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_COMMITTED)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果Xmax被锁定，可见</span></span><br><span class="line">    <span class="keyword">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Xmin已提交，Xmax为组合事务</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI)</span><br><span class="line">&#123;</span><br><span class="line">    TransactionId xmax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Xmax被锁定，可见</span></span><br><span class="line">    <span class="keyword">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    xmax = HeapTupleGetUpdateXid(tuple);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Xmax是当前事务</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionIdIsCurrentTransactionId(xmax))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Xmax正在被某个后端进程执行</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionIdIsInProgress(xmax))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Xmax已经被提交</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionIdDidCommit(xmax))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 否则事务被中断或崩溃</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Xmin已提交，Xmax不是组合事务</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xmax是当前事务</span></span><br><span class="line"><span class="keyword">if</span> (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Xmax正在被某个后端进程执行</span></span><br><span class="line"><span class="keyword">if</span> (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Xmax已经被提交</span></span><br><span class="line"><span class="keyword">if</span> (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// it must have aborted or crashed</span></span><br><span class="line">    SetHintBits(tuple, buffer, HEAP_XMAX_INVALID,</span><br><span class="line">                InvalidTransactionId);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Xmax被锁定</span></span><br><span class="line"><span class="keyword">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))</span><br><span class="line">&#123;</span><br><span class="line">    SetHintBits(tuple, buffer, HEAP_XMAX_INVALID,</span><br><span class="line">                InvalidTransactionId);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SNAPSHOT_SELF</code>所对应的MVCC判断机制如上，其他snapshot类型对应的判断逻辑类似，就不再详细介绍了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB&quot;&gt;事务隔离级别&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A0%87%E5%87%86%E4%BA%8B%E5%8A%A</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/tags/PostgreSQL/"/>
    
    <category term="transaction" scheme="https://spike1337.github.io/tags/transaction/"/>
    
    <category term="MVCC" scheme="https://spike1337.github.io/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL · 源码解析 · WAL日志</title>
    <link href="https://spike1337.github.io/2023/02/03/pg-wal-source-code/"/>
    <id>https://spike1337.github.io/2023/02/03/pg-wal-source-code/</id>
    <published>2023-02-03T05:44:58.000Z</published>
    <updated>2023-02-28T07:03:40.748Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#wal%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">WAL日志文件</a><ul><li><a href="#wal%E6%AE%B5%E6%96%87%E4%BB%B6">WAL段文件</a></li><li><a href="#wal%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84">WAL文件内部结构</a><ul><li><a href="#page%E7%BB%93%E6%9E%84">Page结构</a></li><li><a href="#record%E7%BB%93%E6%9E%84">Record结构</a></li></ul></li></ul></li><li><a href="#wal%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E5%AE%9E%E7%8E%B0">WAL日志写入实现</a><ul><li><a href="#%E6%95%B4%E9%A1%B5%E5%86%99%E5%85%A5full_write_page">整页写入(Full_Write_Page)</a></li><li><a href="#%E5%85%B7%E4%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">具体数据结构</a><ul><li><a href="#xlog-page">XLog Page</a><ul><li><a href="#xlogpageheaderdata">XLogPageHeaderData</a></li><li><a href="#xloglongpageheaderdata">XLogLongPageHeaderData</a></li></ul></li><li><a href="#xlog-record">XLog Record</a><ul><li><a href="#xlogrecord">XLogRecord</a></li><li><a href="#xlogrecordblockheader">XLogRecordBlockHeader</a></li><li><a href="#xlogrecordblockimageheader">XLogRecordBlockImageHeader</a></li><li><a href="#xlogrecordblockcompressheader">XLogRecordBlockCompressHeader</a></li></ul></li><li><a href="#xlog-data">XLog Data</a><ul><li><a href="#xlogrecorddataheader">XLogRecordDataHeader</a></li><li><a href="#xlogrecdata">XLogRecData</a></li></ul></li><li><a href="#xlog%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">XLog控制结构</a><ul><li><a href="#xlogctldata">XLogCtlData</a></li><li><a href="#register_buffer">Register_buffer</a></li></ul></li><li><a href="#%E9%87%8D%E8%A6%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">重要全局变量</a></li></ul></li><li><a href="#%E5%85%B7%E4%BD%93%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81">具体函数代码</a><ul><li><a href="#xlogbegininsert">XLogBeginInsert</a></li><li><a href="#xlogregisterdata">XLogRegisterData</a></li><li><a href="#xlogregisterbuffer">XLogRegisterBuffer</a></li><li><a href="#xlogregisterbufdata">XLogRegisterBufData</a></li><li><a href="#xloginsert">XLogInsert</a></li><li><a href="#xlogrecordassemble">XLogRecordAssemble</a></li><li><a href="#xloginsertrecord">XLogInsertRecord</a></li><li><a href="#pagesetlsn">PageSetLSN</a></li></ul></li></ul></li></ul><hr><br><p>Postgresql 使用 wal 日志保存每一次的数据修改，这样保证了数据库即使意外宕机，也能利用它准确的恢复数据。wal 日志也叫做 xlog，在 9.4 版本之后作了重大更新，本篇只讲解最新版的格式。wal 日志被用于多个方面，比如修改数据，修改索引等，每种用途的格式都不相同，但是构建方式是相同的。</p><h2 id="WAL日志文件">WAL日志文件</h2><h3 id="WAL段文件">WAL段文件</h3><p>WAL日志文件存放在sd_wal目录下，每个文件大小默认为16M：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000B6</span><br><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000B7</span><br><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000B8</span><br><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000B9</span><br><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000BA</span><br><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000BB</span><br><span class="line">drwx------  2 zhangze  zhangze        68 Oct  8 10:53 archive_status</span><br></pre></td></tr></table></figure><p>文件名由16进制的24个字符组成，每8个字符为一组，每组意义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000001 00000000 000000B6</span><br><span class="line"> 时间线    LogID    LogSeg</span><br></pre></td></tr></table></figure><ul><li><strong>时间线</strong>：时间线ID，取值范围为 0x00000000 -&gt; 0xFFFFFFFF。数据库建好后的第一个WAL日志文件的时间线ID从1开始</li><li><strong>LogID</strong>：逻辑文件ID，取值范围为 0x00000000 -&gt; 0xFFFFFFFF</li><li><strong>LogSeg</strong>：物理文件ID，取值范围为 0x00000000 -&gt; 0x000000FF。数据库建好后的第一个WAL日志文件的LogSeg从1开始，达到最大值（0xFF）后从0开始。</li></ul><p><strong>LSN</strong>即日志序列号，表示XLog记录在事务日志文件中的偏移，为uint64值。LSN由三部分组成，分别是逻辑文件ID，物理文件ID和文件内偏移量。LSN打印出来是两个8位的十六进制数，如16/B374D848。由专门的类型<code>pg_lsn</code>来存放LSN数据</p><p>PG WAL文件名字的命名方法是在XLogFileName宏里定义的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XLogSegmentsPerXLogId(wal_segsz_bytes)  \</span></span><br><span class="line"><span class="meta">    (UINT64CONST(0x100000000) / (wal_segsz_bytes))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XLogFileName(fname, tli, logSegNo, wal_segsz_bytes) \</span></span><br><span class="line"><span class="meta">    snprintf(fname, MAXFNAMELEN, <span class="string">&quot;%08X%08X%08X&quot;</span>, tli,       \</span></span><br><span class="line"><span class="meta">             (uint32) ((logSegNo) / XLogSegmentsPerXLogId(wal_segsz_bytes)), \</span></span><br><span class="line"><span class="meta">             (uint32) ((logSegNo) % XLogSegmentsPerXLogId(wal_segsz_bytes)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XLogFileNameById(fname, tli, log, seg)  \</span></span><br><span class="line"><span class="meta">    snprintf(fname, MAXFNAMELEN, <span class="string">&quot;%08X%08X%08X&quot;</span>, tli, log, seg)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IsXLogFileName(fname) \</span></span><br><span class="line"><span class="meta">    (strlen(fname) == XLOG_FNAME_LEN &amp;&amp; \</span></span><br><span class="line"><span class="meta">     strspn(fname, <span class="string">&quot;0123456789ABCDEF&quot;</span>) == XLOG_FNAME_LEN)</span></span><br></pre></td></tr></table></figure><h3 id="WAL文件内部结构">WAL文件内部结构</h3><p>每个WAL段文件由多个8kb大小的page组成，每个Page中存放着PageHeader信息，以及多条WAL Record</p><h4 id="Page结构">Page结构</h4><p>每个page的组织方式如下图：</p><p><img src="/uploads/WALPage.png" alt="WAL的page结构"></p><ul><li><strong>PageHeader</strong>：在wal page的组成中有两种pageheader结构，<code>XLogPageHeaderData</code>和<code>XLogLongPageHeaderData</code>。每个WAL段的第一个Page的Header应为LongHeader</li><li><strong>Remain data</strong>：存储着上一个page中最后一个Record没有存完的数据，大小为<code>xlp_rem_len</code>，对应page的不完整Record</li><li><strong>Record</strong>：存储具体的WAL Record</li><li><strong>无数据区域</strong>：一个WAL Record的头部信息不允许跨页，如果剩余空间不够存储头部信息，则舍弃这部分空间</li></ul><h4 id="Record结构">Record结构</h4><p>每个WAL Record的结构如下图，绿色部分为数据描述结构，黄色部分是实际保存的数据</p><p><img src="/uploads/wal_write.png" alt="WAL_Record"></p><ul><li><strong>XLogRecord</strong>：一个WAL记录的入口，解析WAL时，从这个结构体入手</li><li><strong>Block</strong>：第一个虚线框称为一个BLOCK，用以描述Buffer相关的数据结构。通过<code>XLogRegisterBuffer()</code>函数注册到wal记录中<ul><li><strong>XLogRecordBlockHeader</strong>：一个BLOCK的头部信息</li><li><strong>XLogRecordBlockImageHeader</strong>：如果该WAL是fpw记录，该结构存放fpw相关信息<ul><li>fpw：Full_page_write，具体见<a href="#%E6%95%B4%E9%A1%B5%E5%86%99%E5%85%A5full_write_page">整页写入</a></li></ul></li><li><strong>XLogRecordBlockCompressHeader</strong>：记录hole的大小<ul><li>hole：数据文件的page中，可能会有一块空白区域，即pointer和tuple之间的区域，称为hole</li></ul></li><li><strong>RelFilenode</strong>：此结构记录了此block所属的关系</li><li><strong>BlockNumber</strong>：此block记录的page的块号</li></ul></li><li><strong>XLogRecordDataHeader(Long/short)</strong>：当main data的大小大于255时，使用Long Header</li><li><strong>buffer data</strong>：第二个虚线框部分，包括page data和tuple data<ul><li><strong>page data</strong>：由<code>XLogRegisterBuffer()</code>函数注册到wal记录，存放buffer page信息</li><li><strong>tuple data</strong>：由<code>XLogRegisterBufData()</code>函数注册到wal记录，存储了实际的buff数据和变更数据。</li></ul></li><li><strong>main data</strong>：保存非buffer性的数据，由<code>XLogRegisterData()</code>函数到WAL记录，例如特殊结构体，旧元组或key</li></ul><h2 id="WAL日志写入实现">WAL日志写入实现</h2><p>当数据库数据发生变更时：</p><ul><li>change发生时：先要将变更后内容计入wal buffer中，再将变更后的数据写入data buffer；</li><li>commit发生时：wal buffer中数据刷新到磁盘；</li><li>checkpoint发生时：将所有data buffer刷新的磁盘。</li></ul><p>WAL日志机制就是先将变更内容存放到wal buffer，commit后将wal buffer刷入磁盘的过程。过程中主要的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XLogBeginInsert();        <span class="comment">// 表示开始构建 xlog</span></span><br><span class="line">XLogRegisterData();       <span class="comment">// 将WAL记录的特殊结构体数据注册到WAL，比如heap_insert中的xl_heap_insert结构体</span></span><br><span class="line">XLogRegisterBuffer();     <span class="comment">// 将涉及到的buf注册到wal记录，比如heap_insert中page页赋予regbuf-&gt;page</span></span><br><span class="line">XLogRegisterBufData();    <span class="comment">// 将元组内容注册到WAL记录，比如insert语句的元组数据等</span></span><br><span class="line">XLogSetRecordFlags();</span><br><span class="line">XLogInsert();</span><br><span class="line">    XLogRecordAssemble();</span><br><span class="line">    XLogInsertRecord();   <span class="comment">// 根据当前的数据库状态，把上述函数注册的数据进行筛选组装，最终形成完整的wal记录并写入到walbuff</span></span><br><span class="line">PageSetLSN</span><br></pre></td></tr></table></figure><p><img src="/uploads/wal_process.png" alt="WAL实现过程"></p><h3 id="整页写入-Full-Write-Page">整页写入(Full_Write_Page)</h3><p>如果数据库系统在写入脏页的过程中出现故障，会导致磁盘上的页面数据损坏，而XLOG是无法在损坏的页面上重放的，需要整页写入来恢复。</p><p>如果启用整页写入，PostgreSQL会在每个检查点后，每个页面第一次变更发生前，将整个页面以及Header信息作为一条XLog写入，这个功能默认开启。在数据库恢复过程中，如果检查到一条XLog是一个用来整页写入的备份区块，会使用另一条重放规则：XLog会直接覆盖当前页面，无视页面和XLog记录中的LSN，然后将页面的LSN更新为XLog记录的LSN</p><h3 id="具体数据结构">具体数据结构</h3><h4 id="XLog-Page">XLog Page</h4><h5 id="XLogPageHeaderData">XLogPageHeaderData</h5><p>XLog日志分为很多逻辑段文件，每个段文件分成许多个页面，每个页面的大小为一个块的大小。每个日志页面都有一个头部信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogPageHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint16xlp_magic;<span class="comment">// 校验位，检验WAL的版本信息</span></span><br><span class="line">    uint16xlp_info;<span class="comment">// 标记位</span></span><br><span class="line">    TimeLineIDxlp_tli;<span class="comment">// 页面第一条记录的时间序列</span></span><br><span class="line">    XLogRecPtrxlp_pageaddr;<span class="comment">// XLog页面的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前页面没有足够空间用于记录时，继续在下一页记录</span></span><br><span class="line">    <span class="comment">// 记录了前一页的剩余字节数，包括备份块数据，即该记录在本页继续存储占用的空间大小</span></span><br><span class="line">    uint32xlp_rem_len;</span><br><span class="line">&#125; XLogPageHeaderData;</span><br></pre></td></tr></table></figure><ul><li>其中，标记位<code>xlp_info</code>只使用最低两位，0表明该页的第一个XLog记录接着上一页的最后一个XLog记录，1表示该页是该XLog文件的首页</li></ul><h5 id="XLogLongPageHeaderData">XLogLongPageHeaderData</h5><p>如果页面是该日志文件的首页，那么在原头部信息的基础上会使用一个长的头部信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogLongPageHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XLogPageHeaderData <span class="built_in">std</span>;<span class="comment">// 标准的头部信息，即 XLogPageHeaderData</span></span><br><span class="line">    uint64xlp_sysid;<span class="comment">// pg_control中的系统标识符</span></span><br><span class="line">    uint32xlp_seg_size;<span class="comment">// 校验位，段的大小</span></span><br><span class="line">    uint32xlp_XLog_blcksz;<span class="comment">// 校验位，块的大小</span></span><br><span class="line">&#125; XLogLongPageHeaderData;</span><br></pre></td></tr></table></figure><ul><li>对于长的XLog日志记录，允许将没有足够空间存储的数据存储到下一个页面，但不允许Record头部信息被分开存储到两个不同页面。如果剩余空间已经不足以存储一个头部信息，那么剩余空间将被舍弃，将这个XLog记录存储到新的下一个页面中</li></ul><h4 id="XLog-Record">XLog Record</h4><h5 id="XLogRecord">XLogRecord</h5><p>结构<code>XLogRecord</code>记录了XLog的相关控制信息，一个XLog记录最多可以附3个备份块， 每个块对应一个磁盘大小的数据，长度为8kb</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecord</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint32xl_tot_len;<span class="comment">// 整条记录的长度</span></span><br><span class="line">TransactionId xl_xid;<span class="comment">// 事务ID</span></span><br><span class="line">XLogRecPtrxl_prev;<span class="comment">// 指向日志中的前一个记录</span></span><br><span class="line">uint8xl_info;<span class="comment">// 信息标记位</span></span><br><span class="line">RmgrIdxl_rmid;<span class="comment">// 资源管理器</span></span><br><span class="line"></span><br><span class="line">pg_crc32cxl_crc;<span class="comment">// 本记录的CRC校验码</span></span><br><span class="line">&#125; XLogRecord;</span><br></pre></td></tr></table></figure><ul><li>其中，资源管理器号主要用于日志系统中，数据库系统需要将记录的日志数据分类，为它们分配对应的资源管理器号。读取日志记录时，结合资源管理器号和信息标志位，能够直到数据库对源数据做的是哪种操作，从而迅速正确的调用对应的函数。共有16种资源</li><li>信息标志位的高4位由资源管理器使用，标识该日志是哪种类型的日志。低4位表示对应的块是否需要备份</li></ul><h5 id="XLogRecordBlockHeader">XLogRecordBlockHeader</h5><p>存放block的相关信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordBlockHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint8       id;             <span class="comment">// 块引用ID</span></span><br><span class="line">    uint8       fork_flags;     <span class="comment">// 在关系中使用的fork和flags</span></span><br><span class="line">    uint16      data_length;    <span class="comment">// payload字节大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了 BKPBLOCK_HAS_IMAGE,后续为XLogRecordBlockImageHeader结构体，否则为RelFileNode</span></span><br><span class="line">    <span class="comment">//之后为BlockNumber</span></span><br><span class="line">&#125; XLogRecordBlockHeader;</span><br></pre></td></tr></table></figure><h5 id="XLogRecordBlockImageHeader">XLogRecordBlockImageHeader</h5><p>存放整页写入的相关信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordBlockImageHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint16length;<span class="comment">// page大小</span></span><br><span class="line">uint16hole_offset;<span class="comment">// hole之前的长度</span></span><br><span class="line">uint8bimg_info;<span class="comment">// 标记位，是否压缩</span></span><br><span class="line">&#125; XLogRecordBlockImageHeader;</span><br></pre></td></tr></table></figure><h5 id="XLogRecordBlockCompressHeader">XLogRecordBlockCompressHeader</h5><p>存放page中的hole大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordBlockCompressHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint16hole_length;<span class="comment">// hole大小</span></span><br><span class="line">&#125; XLogRecordBlockCompressHeader;</span><br></pre></td></tr></table></figure><h4 id="XLog-Data">XLog Data</h4><h5 id="XLogRecordDataHeader">XLogRecordDataHeader</h5><p>WAL Record的数据部分的header信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordDataHeaderShort</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint8       id;</span><br><span class="line">    uint8       data_length;</span><br><span class="line">&#125;XLogRecordDataHeaderShort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordDataHeaderLong</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint8       id;</span><br><span class="line">&#125;XLogRecordDataHeaderLong;</span><br></pre></td></tr></table></figure><h5 id="XLogRecData">XLogRecData</h5><p>XLog日志记录中的数据信息存储在结构<code>XLogRecData</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XLogRecData</span> *<span class="title">next</span>;</span><span class="comment">// 下一个节点</span></span><br><span class="line"><span class="type">char</span>    *data;<span class="comment">// 数据</span></span><br><span class="line">uint32len;<span class="comment">// 数据长度</span></span><br><span class="line">&#125; XLogRecData;</span><br></pre></td></tr></table></figure><h4 id="XLog控制结构">XLog控制结构</h4><h5 id="XLogCtlData">XLogCtlData</h5><p>在共享内存中用结构<code>XLogCtlData</code>保存XLog信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogCtlData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XLogCtlInsert Insert;<span class="comment">// 插入一条日志后，最新的相关信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下受info_lck保护</span></span><br><span class="line">    XLogwrtRqst LogwrtRqst;<span class="comment">// 将日志写入和同步的位置</span></span><br><span class="line">    XLogRecPtrRedoRecPtr;<span class="comment">// 最近的 Insert-&gt;RedoRecPtr 副本</span></span><br><span class="line">    FullTransactionId ckptFullXid;<span class="comment">// 最新检查点的nextXID</span></span><br><span class="line">    XLogRecPtrasyncXactLSN;<span class="comment">// 最新异步提交/中断的LSN</span></span><br><span class="line">    XLogRecPtrreplicationSlotMinLSN;<span class="comment">// 所有缓冲区所需的最老的LSN</span></span><br><span class="line"></span><br><span class="line">    XLogSegNolastRemovedSegNo;<span class="comment">// 最后的删除/回收的XLog段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于不需要记录日志的关系的假的LSN</span></span><br><span class="line">    XLogRecPtrunloggedLSN;</span><br><span class="line">    <span class="type">slock_t</span>ulsn_lck;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换后最新的XLog的时间和LSN，受XLogWriteLock保护</span></span><br><span class="line">    <span class="type">pg_time_t</span>lastSegSwitchTime;</span><br><span class="line">    XLogRecPtrlastSegSwitchLSN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经写入和同步的位置，受info_lck或XLogWriteLock保护</span></span><br><span class="line">    XLogwrtResult LogwrtResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存中的最后初始化页面，最后一个字节位置+1</span></span><br><span class="line">    XLogRecPtrInitializedUpTo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些值在启动后不会修改，尽管指向的页面和xlblocks通常会改变</span></span><br><span class="line">    <span class="comment">// xlblocks受 XLogBufMappingLock 保护</span></span><br><span class="line">    <span class="type">char</span>   *pages;<span class="comment">// 未写入XLog页面的缓冲区</span></span><br><span class="line">    XLogRecPtr *xlblocks;<span class="comment">// 缓冲区内容对应的XLog文件的内部指针</span></span><br><span class="line">    <span class="type">int</span>XLogCacheBlck;<span class="comment">// XLog最大缓冲区的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThisTimeLineID 的共享副本，在完成恢复后不要修改</span></span><br><span class="line">    TimeLineIDThisTimeLineID;</span><br><span class="line">    TimeLineIDPrevTimeLineID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记我们是否处于崩溃或恢复状态，受info_lock保护</span></span><br><span class="line">    RecoveryState SharedRecoveryState;</span><br><span class="line">    <span class="type">bool</span>SharedHotStandbyActive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示XLog写入是否处于节能模式，受info_lock保护</span></span><br><span class="line">    <span class="type">bool</span>XLogWriterSleeping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待唤醒，如果出现出发文件，则唤醒启动进程以继续执行XLog重放</span></span><br><span class="line">    LatchrecoveryWakeupLatch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在恢复期间保留最后检查点记录的副本，受info_lck保护</span></span><br><span class="line">    XLogRecPtrlastCheckPointRecPtr;</span><br><span class="line">    XLogRecPtrlastCheckPointEndPtr;</span><br><span class="line">    CheckPointlastCheckPoint;</span><br><span class="line"></span><br><span class="line">    XLogRecPtrlastReplayedEndRecPtr;<span class="comment">// 指向成功重放的最后一条记录的结尾+1</span></span><br><span class="line">    TimeLineIDlastReplayedTLI;</span><br><span class="line">    XLogRecPtrreplayEndRecPtr;<span class="comment">// 如果正处于redo函数回放记录期间，则指向正在恢复记录的结尾+1</span></span><br><span class="line">    <span class="comment">// 否则等于lastReplayedEndRecPtr</span></span><br><span class="line">    TimeLineIDreplayEndTLI;</span><br><span class="line">    TimestampTz recoveryLastXTime;<span class="comment">// 重放（正在重放）的最后一个COMMIT/ABORT记录的时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始重放当前XLog数据块的时间戳</span></span><br><span class="line">    TimestampTz currentChunkStartTime;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span>recoveryPause;<span class="comment">// 是否暂停恢复</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向最后重放的XLog_FPW_CHANGE记录的起始点</span></span><br><span class="line">    <span class="comment">// 用于禁用full_page_writes</span></span><br><span class="line">    XLogRecPtrlastFpwDisableRecPtr;</span><br><span class="line"></span><br><span class="line">    <span class="type">slock_t</span>info_lck;<span class="comment">// 共享锁</span></span><br><span class="line">&#125; XLogCtlData;</span><br></pre></td></tr></table></figure><h5 id="Register-buffer">Register_buffer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">bool</span>in_use;<span class="comment">// is this slot in use?</span></span><br><span class="line">uint8flags;<span class="comment">// REGBUF_* flags</span></span><br><span class="line">RelFileNode rnode;<span class="comment">// 指定所属表的存储目录</span></span><br><span class="line">ForkNumberforkno;         <span class="comment">// 哪种文件类型</span></span><br><span class="line">BlockNumber block;          <span class="comment">// 块编号</span></span><br><span class="line">Pagepage;<span class="comment">// 对应的原始数据页</span></span><br><span class="line"></span><br><span class="line">uint32rdata_len;<span class="comment">// 私有数据链表的长度总和</span></span><br><span class="line">XLogRecData *rdata_head;<span class="comment">// 私有数据链表头部节点</span></span><br><span class="line">XLogRecData *rdata_tail;<span class="comment">// 私有数据链表尾部节点</span></span><br><span class="line"></span><br><span class="line">XLogRecData bkp_rdatas[<span class="number">2</span>];<span class="comment">// 存储着压缩后或忽略空闲数据的数据，如果有空闲位置且没有压缩，那么数据会被分成两个部分，存储在两个数组元素里</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>compressed_page[PGLZ_MAX_BLCKSZ]; <span class="comment">// 如果开启了压缩，那么存储着压缩后的数据</span></span><br><span class="line">&#125; registered_buffer;</span><br></pre></td></tr></table></figure><h4 id="重要全局变量">重要全局变量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> XLogRecData *mainrdata_head;</span><br><span class="line"><span class="type">static</span> XLogRecData *mainrdata_last = (XLogRecData *) &amp;mainrdata_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用XLogRegisterBuffer注册的数据存储到registered_buffers数组里*/</span></span><br><span class="line"><span class="type">static</span> registered_buffer *registered_buffers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用XLogRegisterBufData注册的数据存储到rdatas数组里，并链接为链表，使用registered_buffer结构里的rdata_head和</span></span><br><span class="line"><span class="comment"> * rdata_tail作为链表的首尾。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用XLogRegisterData注册的数据存储到rdatas数组里，并使用mainrdata_head和mainrdata_lastata注册的数据存储到rdatas数组里，</span></span><br><span class="line"><span class="comment"> * 并链接为链表，使用registered_buffer结构里的rdata_head和rdata_tail作为链表的首尾。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> XLogRecData *rdatas;</span><br></pre></td></tr></table></figure><h3 id="具体函数代码">具体函数代码</h3><h4 id="XLogBeginInsert">XLogBeginInsert</h4><p>函数主要作用是检验调用环境是否正确，判断当前是否可以执行xlog插入，并设置开始构造WAL记录的标记，标志wal插入开始。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Assert(max_registered_block_id == <span class="number">0</span>);</span><br><span class="line">Assert(mainrdata_last == (XLogRecData *) &amp;mainrdata_head);</span><br><span class="line">Assert(mainrdata_len == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!XLogInsertAllowed())</span><br><span class="line">    elog(ERROR, <span class="string">&quot;cannot make new WAL entries during recovery&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (begininsert_called)</span><br><span class="line">    elog(ERROR, <span class="string">&quot;XLogBeginInsert was already called&quot;</span>);</span><br><span class="line"></span><br><span class="line">begininsert_called = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="XLogRegisterData">XLogRegisterData</h4><ol><li><p>将本条wal记录的特殊结构体数据注册到wal记录，比如XLOG_HEAP_INSERT子类型的xl_heap_insert结构体。</p></li><li><p>将一些旧元组数据注册到wal记录，比如执行update语句的旧元组数据、delete语句的旧元组数据。</p></li></ol><p><img src="/uploads/xlog_register_data.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否已经开始构造WAL</span></span><br><span class="line">Assert(begininsert_called);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查数据量是否超过限制值</span></span><br><span class="line"><span class="keyword">if</span> (num_rdatas &gt;= max_rdatas)</span><br><span class="line">    elog(ERROR, <span class="string">&quot;too much WAL data&quot;</span>);</span><br><span class="line">rdata = &amp;rdatas[num_rdatas++];</span><br><span class="line"></span><br><span class="line">rdata-&gt;data = data;</span><br><span class="line">rdata-&gt;len = len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 mainrdata_last 指针跟踪链条的结束点,在这里不需要清除next变量</span></span><br><span class="line">mainrdata_last-&gt;next = rdata;</span><br><span class="line">mainrdata_last = rdata;</span><br><span class="line"></span><br><span class="line">mainrdata_len += len;</span><br></pre></td></tr></table></figure><h4 id="XLogRegisterBuffer">XLogRegisterBuffer</h4><p>将涉及到的buff注册到wal记录，比如insert语句的目标buff、update语句的目标buff和源buff</p><p><img src="/uploads/xlog_register_buf.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到registered_buffer数组中第一个空的的位置</span></span><br><span class="line"><span class="keyword">if</span> (block_id &gt;= max_registered_block_id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (block_id &gt;= max_registered_buffers)</span><br><span class="line">        elog(ERROR, <span class="string">&quot;too many registered buffers&quot;</span>);</span><br><span class="line">    max_registered_block_id = block_id + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将这个buffer的数据填充</span></span><br><span class="line">regbuf = &amp;registered_buffers[block_id];</span><br><span class="line"></span><br><span class="line">BufferGetTag(buffer, &amp;regbuf-&gt;rnode, &amp;regbuf-&gt;forkno, &amp;regbuf-&gt;block);</span><br><span class="line">regbuf-&gt;page = BufferGetPage(buffer);</span><br><span class="line">regbuf-&gt;flags = flags;</span><br><span class="line">regbuf-&gt;rdata_tail = (XLogRecData *) &amp;regbuf-&gt;rdata_head;</span><br><span class="line">regbuf-&gt;rdata_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓冲区标记为已使用</span></span><br><span class="line">regbuf-&gt;in_use = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="XLogRegisterBufData">XLogRegisterBufData</h4><p>函数主要作用是将元组内容注册到WAL记录中。需要参数block id，这个id必须是已经通过<code>XLogRegisterBuffer</code>注册的block</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取已经注册的缓冲区结构</span></span><br><span class="line">regbuf = &amp;registered_buffers[block_id];</span><br><span class="line"><span class="keyword">if</span> (!regbuf-&gt;in_use)</span><br><span class="line">    elog(ERROR, <span class="string">&quot;no block with id %d registered with WAL insertion&quot;</span>,</span><br><span class="line">         block_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取buffer数据</span></span><br><span class="line"><span class="keyword">if</span> (num_rdatas &gt;= max_rdatas)</span><br><span class="line">    elog(ERROR, <span class="string">&quot;too much WAL data&quot;</span>);</span><br><span class="line">rdata = &amp;rdatas[num_rdatas++];</span><br><span class="line"></span><br><span class="line">rdata-&gt;data = data;</span><br><span class="line">rdata-&gt;len = len;</span><br><span class="line"></span><br><span class="line">regbuf-&gt;rdata_tail-&gt;next = rdata;</span><br><span class="line">regbuf-&gt;rdata_tail = rdata;</span><br><span class="line">regbuf-&gt;rdata_len += len;</span><br></pre></td></tr></table></figure><h4 id="XLogInsert">XLogInsert</h4><p>插入WAL的操作由函数<code>XLogInsert</code>完成，根据Rdata链表和相应的资源管理器info向WAL日志文件中插入一条WAL记录。事务执行插入，删除，更新，提交，终止或回滚命令时都需要调用此函数</p><ul><li>判断调用时是否设置了rmgr标记位：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((info &amp; ~(XLR_RMGR_INFO_MASK |</span><br><span class="line">              XLR_SPECIAL_REL_UPDATE |</span><br><span class="line">              XLR_CHECK_CONSISTENCY)) != <span class="number">0</span>)</span><br><span class="line">    elog(PANIC, <span class="string">&quot;invalid xlog info mask %02X&quot;</span>, info);</span><br></pre></td></tr></table></figure><ul><li>如果处于bootstrap模式，除了XLog资源外，不需要实际记录内容，指向第一个检查点的指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsBootstrapProcessingMode() &amp;&amp; rmid != RM_XLog_ID)</span><br><span class="line">&#123;</span><br><span class="line">    XLogResetInsertion();</span><br><span class="line">    EndPos = SizeOfXLogLongPHD;</span><br><span class="line">    <span class="keyword">return</span> EndPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组合成完整的WAL记录并写入WAL日志</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    XLogRecPtrRedoRecPtr;</span><br><span class="line">    <span class="type">bool</span>doPageWrites;</span><br><span class="line">    XLogRecPtrfpw_lsn;</span><br><span class="line">    XLogRecData *rdt;</span><br><span class="line"></span><br><span class="line">    GetFullPageWriteInfo(&amp;RedoRecPtr, &amp;doPageWrites);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数组装注册的数据</span></span><br><span class="line">    rdt = XLogRecordAssemble(rmid, info, RedoRecPtr, doPageWrites,</span><br><span class="line">                             &amp;fpw_lsn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将组装好的数据写入到WAL内存中</span></span><br><span class="line">    EndPos = XLogInsertRecord(rdt, fpw_lsn, curinsert_flags);</span><br><span class="line">&#125; <span class="keyword">while</span> (EndPos == InvalidXLogRecPtr);</span><br></pre></td></tr></table></figure><h4 id="XLogRecordAssemble">XLogRecordAssemble</h4><p>函数用于将已注册的数据和缓冲区页面数据组装成一条WAL记录，将其写入到<code>XLogRecData</code>链表中。</p><p>执行到这个阶段，wal记录的数据存储在：</p><ol><li>mainrdata_head</li><li>每一个注册的buff的rdata_head</li><li>每一个注册的buff的page字段中</li></ol><p>函数执行过程如下：</p><ul><li>保存头部信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">XLogRecData *rdt;<span class="comment">// XLogRecData链表指针</span></span><br><span class="line">uint32total_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>block_id;</span><br><span class="line">pg_crc32crdata_crc;</span><br><span class="line">registered_buffer *prev_regbuf = <span class="literal">NULL</span>;</span><br><span class="line">XLogRecData *rdt_datas_last;</span><br><span class="line">XLogRecord *rechdr;</span><br><span class="line"><span class="type">char</span>   *scratch = hdr_scratch;</span><br><span class="line"></span><br><span class="line">rechdr = (XLogRecord *) scratch;</span><br><span class="line">scratch += SizeOfXLogRecord;</span><br><span class="line"></span><br><span class="line">hdr_rdt.next = <span class="literal">NULL</span>;</span><br><span class="line">rdt_datas_last = &amp;hdr_rdt;</span><br><span class="line">hdr_rdt.data = hdr_scratch;</span><br></pre></td></tr></table></figure><ul><li>构造保存所有块公用的数据部分的rdata链</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">*fpw_lsn = InvalidXLogRecPtr;</span><br><span class="line"><span class="keyword">for</span> (block_id = <span class="number">0</span>; block_id &lt; max_registered_block_id; block_id++)</span><br><span class="line">&#123;</span><br><span class="line">    registered_buffer *regbuf = &amp;registered_buffers[block_id];</span><br><span class="line">    XLogRecordBlockHeader bkpb;</span><br><span class="line">    XLogRecordBlockImageHeader bimg;</span><br><span class="line">    XLogRecordBlockCompressHeader cbimg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">bool</span>samerel;</span><br><span class="line">    <span class="type">bool</span>is_compressed = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span>include_image;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置block头部信息</span></span><br><span class="line">    bkpb.id = block_id;</span><br><span class="line">    bkpb.fork_flags = regbuf-&gt;forkno;</span><br><span class="line">    bkpb.data_length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置标记位</span></span><br><span class="line">    <span class="keyword">if</span> ((regbuf-&gt;flags &amp; REGBUF_WILL_INIT) == REGBUF_WILL_INIT)</span><br><span class="line">        bkpb.fork_flags |= BKPBLOCK_WILL_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行full_page_write，写入XLogRecordBlockImageHeader</span></span><br><span class="line">    <span class="keyword">if</span> (include_image)</span><br><span class="line">    &#123;</span><br><span class="line">        Page        page = regbuf-&gt;page;<span class="comment">// 获取对应的page</span></span><br><span class="line">        uint16      compressed_len = <span class="number">0</span>;<span class="comment">// 压缩后的大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// page需要备份，计算空闲空间大小和偏移</span></span><br><span class="line">        <span class="comment">// &quot;hole&quot;指的是page中的空白区域</span></span><br><span class="line">        <span class="keyword">if</span> (regbuf-&gt;flags &amp; REGBUF_STANDARD)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果页面遵循标准布局，lower和upper指针将被跳过</span></span><br><span class="line">            uint16      lower = ((PageHeader) page)-&gt;pd_lower;<span class="comment">// 获取lower</span></span><br><span class="line">            uint16      upper = ((PageHeader) page)-&gt;pd_upper;<span class="comment">// 获取upper</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断page中是否存在&quot;hole&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (lower &gt;= SizeOfPageHeaderData &amp;&amp;</span><br><span class="line">                upper &gt; lower &amp;&amp;</span><br><span class="line">                upper &lt;= BLCKSZ)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 计算“hole”的长度的偏移量</span></span><br><span class="line">                bimg.hole_offset = lower;</span><br><span class="line">                cbimg.hole_length = upper - lower;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 没有可以移除的&quot;hole&quot;</span></span><br><span class="line">                bimg.hole_offset = <span class="number">0</span>;</span><br><span class="line">                cbimg.hole_length = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不是标准的页面布局，无法尝试估算&quot;hole&quot;</span></span><br><span class="line">            bimg.hole_offset = <span class="number">0</span>;</span><br><span class="line">            cbimg.hole_length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用WAL压缩</span></span><br><span class="line">        <span class="keyword">if</span> (wal_compression)</span><br><span class="line">        &#123;</span><br><span class="line">            is_compressed =</span><br><span class="line">                XLogCompressBackupBlock(page, bimg.hole_offset,</span><br><span class="line">                                        cbimg.hole_length,</span><br><span class="line">                                        regbuf-&gt;compressed_page,</span><br><span class="line">                                        &amp;compressed_len);<span class="comment">// 调用XLogCompressBackupBlock压缩</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充XLogRecordBlockHeader结构体的剩余字段</span></span><br><span class="line">        bkpb.fork_flags |= BKPBLOCK_HAS_IMAGE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为page内容构造XLogRecData入口</span></span><br><span class="line">        rdt_datas_last-&gt;next = &amp;regbuf-&gt;bkp_rdatas[<span class="number">0</span>];</span><br><span class="line">        rdt_datas_last = rdt_datas_last-&gt;next;</span><br><span class="line">        <span class="comment">// 设置标记</span></span><br><span class="line">        bimg.bimg_info = (cbimg.hole_length == <span class="number">0</span>) ? <span class="number">0</span> : BKPIMAGE_HAS_HOLE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在redo期间,在设置了BKPIMAGE_APPLY标记的情况下full-page才会回放.</span></span><br><span class="line">        <span class="keyword">if</span> (needs_backup)</span><br><span class="line">            bimg.bimg_info |= BKPIMAGE_APPLY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要压缩</span></span><br><span class="line">        <span class="keyword">if</span> (is_compressed)</span><br><span class="line">        &#123;</span><br><span class="line">            bimg.length = compressed_len;<span class="comment">// 压缩后的空间</span></span><br><span class="line">            bimg.bimg_info |= BKPIMAGE_IS_COMPRESSED;<span class="comment">// 压缩标记</span></span><br><span class="line"></span><br><span class="line">            rdt_datas_last-&gt;data = regbuf-&gt;compressed_page;<span class="comment">// 放在registered_buffer中</span></span><br><span class="line">            rdt_datas_last-&gt;len = compressed_len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有压缩，计算image的大小</span></span><br><span class="line">            bimg.length = BLCKSZ - cbimg.hole_length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果没有&quot;hole&quot;存在</span></span><br><span class="line">            <span class="keyword">if</span> (cbimg.hole_length == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rdt_datas_last-&gt;data = page;<span class="comment">// 数据指针直接指向page</span></span><br><span class="line">                rdt_datas_last-&gt;len = BLCKSZ;<span class="comment">// 大小为block size</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 跳过hole</span></span><br><span class="line">                rdt_datas_last-&gt;data = page;<span class="comment">// 数据指针</span></span><br><span class="line">                rdt_datas_last-&gt;len = bimg.hole_offset;<span class="comment">// 获取hole的偏移</span></span><br><span class="line"></span><br><span class="line">                rdt_datas_last-&gt;next = &amp;regbuf-&gt;bkp_rdatas[<span class="number">1</span>];<span class="comment">// 第2部分</span></span><br><span class="line">                rdt_datas_last = rdt_datas_last-&gt;next;</span><br><span class="line"></span><br><span class="line">                rdt_datas_last-&gt;data =</span><br><span class="line">                    page + (bimg.hole_offset + cbimg.hole_length);<span class="comment">// 指针指向第二部分</span></span><br><span class="line">                rdt_datas_last-&gt;len =</span><br><span class="line">                    BLCKSZ - (bimg.hole_offset + cbimg.hole_length);<span class="comment">// 设置长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        total_len += bimg.length;<span class="comment">// 调整总长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要包含数据</span></span><br><span class="line">    <span class="keyword">if</span> (needs_data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把该缓冲区链接到调用者提供的rdata链中，构成一个整体的链表</span></span><br><span class="line">        bkpb.fork_flags |= BKPBLOCK_HAS_DATA;</span><br><span class="line">        bkpb.data_length = regbuf-&gt;rdata_len;</span><br><span class="line">        total_len += regbuf-&gt;rdata_len;</span><br><span class="line"></span><br><span class="line">        rdt_datas_last-&gt;next = regbuf-&gt;rdata_head;</span><br><span class="line">        rdt_datas_last = regbuf-&gt;rdata_tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在上一个注册的buf，而且RefFileNode相同</span></span><br><span class="line">    <span class="keyword">if</span> (prev_regbuf &amp;&amp; RelFileNodeEquals(regbuf-&gt;rnode, prev_regbuf-&gt;rnode))</span><br><span class="line">    &#123;</span><br><span class="line">        samerel = <span class="literal">true</span>;</span><br><span class="line">        bkpb.fork_flags |= BKPBLOCK_SAME_REL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        samerel = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 切换为当前的注册的buf</span></span><br><span class="line">    prev_regbuf = regbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝头部信息到scratch缓冲区中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(scratch, &amp;bkpb, SizeOfXLogRecordBlockHeader);</span><br><span class="line">    scratch += SizeOfXLogRecordBlockHeader;</span><br><span class="line">    <span class="keyword">if</span> (include_image)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(scratch, &amp;bimg, SizeOfXLogRecordBlockImageHeader);</span><br><span class="line">        scratch += SizeOfXLogRecordBlockImageHeader;</span><br><span class="line">        <span class="comment">// 压缩存储,追加SizeOfXLogRecordBlockCompressHeader</span></span><br><span class="line">        <span class="keyword">if</span> (cbimg.hole_length != <span class="number">0</span> &amp;&amp; is_compressed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(scratch, &amp;cbimg,</span><br><span class="line">                   SizeOfXLogRecordBlockCompressHeader);</span><br><span class="line">            scratch += SizeOfXLogRecordBlockCompressHeader;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是同一个REL，追加RelFileNode</span></span><br><span class="line">    <span class="keyword">if</span> (!samerel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(scratch, &amp;regbuf-&gt;rnode, <span class="keyword">sizeof</span>(RelFileNode));</span><br><span class="line">        scratch += <span class="keyword">sizeof</span>(RelFileNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加BlockNumber</span></span><br><span class="line">    <span class="built_in">memcpy</span>(scratch, &amp;regbuf-&gt;block, <span class="keyword">sizeof</span>(BlockNumber));</span><br><span class="line">    scratch += <span class="keyword">sizeof</span>(BlockNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来组装XLog Record origin标记</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((curinsert_flags &amp; XLog_INCLUDE_ORIGIN) &amp;&amp;</span><br><span class="line">    replorigin_session_origin != InvalidRepOriginId)</span><br><span class="line">&#123;</span><br><span class="line">    *(scratch++) = (<span class="type">char</span>) XLR_BLOCK_ID_ORIGIN;</span><br><span class="line">    <span class="built_in">memcpy</span>(scratch, &amp;replorigin_session_origin, <span class="keyword">sizeof</span>(replorigin_session_origin));</span><br><span class="line">    scratch += <span class="keyword">sizeof</span>(replorigin_session_origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来组装数据（main data）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mainrdata_len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 长度超过255，则使用Long格式</span></span><br><span class="line">    <span class="keyword">if</span> (mainrdata_len &gt; <span class="number">255</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *(scratch++) = (<span class="type">char</span>) XLR_BLOCK_ID_DATA_LONG;</span><br><span class="line">        <span class="built_in">memcpy</span>(scratch, &amp;mainrdata_len, <span class="keyword">sizeof</span>(uint32));</span><br><span class="line">        scratch += <span class="keyword">sizeof</span>(uint32);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *(scratch++) = (<span class="type">char</span>) XLR_BLOCK_ID_DATA_SHORT;</span><br><span class="line">        *(scratch++) = (uint8) mainrdata_len;</span><br><span class="line">    &#125;</span><br><span class="line">    rdt_datas_last-&gt;next = mainrdata_head;</span><br><span class="line">    rdt_datas_last = mainrdata_last;</span><br><span class="line">    total_len += mainrdata_len;</span><br><span class="line">&#125;</span><br><span class="line">rdt_datas_last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">hdr_rdt.len = (scratch - hdr_scratch);<span class="comment">// 头部大小</span></span><br><span class="line">total_len += hdr_rdt.len;<span class="comment">// 总长度</span></span><br></pre></td></tr></table></figure><ul><li>计算数据的CRC</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INIT_CRC32C(rdata_crc);</span><br><span class="line">COMP_CRC32C(rdata_crc, hdr_scratch + SizeOfXLogRecord, hdr_rdt.len - SizeOfXLogRecord);</span><br><span class="line"><span class="keyword">for</span> (rdt = hdr_rdt.next; rdt != <span class="literal">NULL</span>; rdt = rdt-&gt;next)</span><br><span class="line">    COMP_CRC32C(rdata_crc, rdt-&gt;data, rdt-&gt;len);</span><br></pre></td></tr></table></figure><ul><li>最后填充记录头部信息的其他域字段</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rechdr-&gt;xl_xid = GetCurrentTransactionIdIfAny();</span><br><span class="line">rechdr-&gt;xl_tot_len = total_len;</span><br><span class="line">rechdr-&gt;xl_info = info;</span><br><span class="line">rechdr-&gt;xl_rmid = rmid;</span><br><span class="line">rechdr-&gt;xl_prev = InvalidXLogRecPtr;</span><br><span class="line">rechdr-&gt;xl_crc = rdata_crc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;hdr_rdt;</span><br></pre></td></tr></table></figure><h4 id="XLogInsertRecord">XLogInsertRecord</h4><p>将<code>XLogRecordAssemble</code>组装好的记录插入到WAL内存中。过程分两步：</p><ul><li>在内存中为WAL记录保留足够的空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isLogSwitch)</span><br><span class="line">    inserted = ReserveXLogSwitch(&amp;StartPos, &amp;EndPos, &amp;rechdr-&gt;xl_prev);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ReserveXLogInsertLocation(rechdr-&gt;xl_tot_len, &amp;StartPos, &amp;EndPos,</span><br><span class="line">                              &amp;rechdr-&gt;xl_prev);</span><br><span class="line">    inserted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将记录复制到WAL内存中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inserted)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算头部的CRC</span></span><br><span class="line">    rdata_crc = rechdr-&gt;xl_crc;</span><br><span class="line">    COMP_CRC32C(rdata_crc, rechdr, offsetof(XLogRecord, xl_crc));</span><br><span class="line">    FIN_CRC32C(rdata_crc);</span><br><span class="line">    rechdr-&gt;xl_crc = rdata_crc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的数据，包括header信息，均可以进行插入</span></span><br><span class="line">    CopyXLogRecordToWAL(rechdr-&gt;xl_tot_len, isLogSwitch, rdata,</span><br><span class="line">                        StartPos, EndPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新最后一条重要记录的LSN，当持有锁时，只更新第一个</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; XLog_MARK_UNIMPORTANT) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>lockno = holdingAllLocks ? <span class="number">0</span> : MyLockNo;</span><br><span class="line"></span><br><span class="line">        WALInsertLocks[lockno].l.lastImportantAt = StartPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PageSetLSN">PageSetLSN</h4><p>更新被修改的Page LSN</p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#wal%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6&quot;&gt;WAL日志文件&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#wal%E6%AE%B5%E6%96%87%E4%BB%B6&quot;&gt;WAL段文件&lt;/a&gt;&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/tags/PostgreSQL/"/>
    
    <category term="replication" scheme="https://spike1337.github.io/tags/replication/"/>
    
    <category term="WAL" scheme="https://spike1337.github.io/tags/WAL/"/>
    
  </entry>
  
</feed>
