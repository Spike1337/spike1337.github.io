<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spike World</title>
  <icon>https://www.gravatar.com/avatar/e1307032b28045ba75cb8251865dfced</icon>
  
  <link href="https://spike1337.github.io/atom.xml" rel="self"/>
  
  <link href="https://spike1337.github.io/"/>
  <updated>2023-09-05T06:50:11.120Z</updated>
  <id>https://spike1337.github.io/</id>
  
  <author>
    <name>Spike1337</name>
    <email>spikeiwnl@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是动态规划</title>
    <link href="https://spike1337.github.io/2023/09/03/dynamic_programming/"/>
    <id>https://spike1337.github.io/2023/09/03/dynamic_programming/</id>
    <published>2023-09-03T06:25:00.000Z</published>
    <updated>2023-09-05T06:50:11.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是动态规划？">什么是动态规划？</h2><p>给定一个复杂问题，将其拆分为多个简单子问题。根据子问题答案反推出复杂问题的答案</p><h2 id="核心思想">核心思想</h2><ul class="lvl-0"><li class="lvl-2"><p>拆分子问题</p></li><li class="lvl-2"><p>求解子问题</p></li><li class="lvl-2"><p>记录子问题答案</p></li><li class="lvl-2"><p>反推父问题答案</p></li></ul><p>动态规划算法即通过记住子问题的答案来节约时间</p><h2 id="解题思路">解题思路</h2><p>以一道LeetCode的题目为例：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br><span class="line"></span><br><span class="line">子数组 是数组中的一个连续部分。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="string">-2</span>,1,<span class="string">-3</span>,4,<span class="string">-1</span>,2,1,<span class="string">-5</span>,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,<span class="string">-1</span>,2,1] 的和最大，为6。</span><br></pre></td></tr></table></figure><h3 id="大致思路">大致思路</h3><p>动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。</p><p>我们求解动态规划问题的大致思路为:</p><ul class="lvl-0"><li class="lvl-2"><p>枚举分析</p></li><li class="lvl-2"><p>确定边界值</p></li><li class="lvl-2"><p>找出规律，得到最优子结构</p></li><li class="lvl-2"><p>写出状态转移方程</p></li></ul><h3 id="具体过程">具体过程</h3><p>观察规律，采用自底向上方法枚举分析:</p><ol><li class="lvl-3"><p>-2 最大子数组 [-2]</p></li><li class="lvl-4"><p>1 最大子数组 [1]</p></li><li class="lvl-3"><p>-3 最大子数组 [1]</p></li><li class="lvl-4"><p>4 最大子数组 [4]</p></li><li class="lvl-3"><p>-1 最大子数组 [4]</p></li><li class="lvl-4"><p>2 最大子数组 [4, -1, 2]</p></li><li class="lvl-4"><p>1 最大子数组 [4, -1, 2, 1]</p></li><li class="lvl-3"><p>-5 最大子数组 [4, -1, 2, 1]</p></li><li class="lvl-4"><p>4 最大子数组 [4, -1, 2, 1]</p></li></ol><p>我们以f(n)来表示以第n个元素结尾的连续子数组的最大和，则maxSubArray = max(f(1), f(2),…,f(n))</p><p>因此我们只需要找出f(n)和f(n-1)之间的关系即可写出动态规划的状态转移方程</p><p>观察枚举结果我们发现:</p><p>f(n)要么是nums[n]的值，要么是nums[n]与第n-1个元素结尾的连续子数组的最大和之和</p><p>即状态转移方程为: f(n) = max(f(n-1) + nums[n], nums[n])</p><p>而边界值显而易见的为nums[0]</p><p>至此我们就可以写出该题的动态规划解法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxSubArray = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> preArray = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;x: nums)</span><br><span class="line">        &#123;</span><br><span class="line">            preArray = <span class="built_in">max</span>(preArray + x, x);</span><br><span class="line">            maxSubArray = <span class="built_in">max</span>(maxSubArray, preArray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSubArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个案例简单了解动态规划算法的使用</summary>
    
    
    
    <category term="Algorithm" scheme="https://spike1337.github.io/categories/Algorithm/"/>
    
    
    <category term="C++, Algorithm" scheme="https://spike1337.github.io/tags/C-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 刷题日记 · 数据结构</title>
    <link href="https://spike1337.github.io/2023/08/31/leetcode_struct/"/>
    <id>https://spike1337.github.io/2023/08/31/leetcode_struct/</id>
    <published>2023-08-31T01:05:00.000Z</published>
    <updated>2023-09-01T09:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树">二叉树</h2><h3 id="226-翻转二叉树">226.翻转二叉树</h3><p>Tag: 二叉树，广度优先搜索，深度优先搜索</p><h4 id="题目">题目</h4><p><a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p><h4 id="Solution1">Solution1</h4><p>遍历二叉树，递归翻转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;right = <span class="built_in">invertTree</span>(tmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树">101.对称二叉树</h3><p>Tags: 二叉树，广度优先搜索，深度优先搜索</p><h4 id="题目-2">题目</h4><p><a href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p><h4 id="Solution1-2">Solution1</h4><p>深度优先搜索，递归判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *left, TreeNode *right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断非空</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((left == <span class="literal">nullptr</span>) &amp;&amp; (right == <span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left-&gt;val != right-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">dfs</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>优点：简洁易懂</p></li><li class="lvl-2"><p>缺点：没啥缺点，但是递归。可以优化为尾递归</p></li><li class="lvl-2"><p>结论：好办法</p></li></ul><h2 id="链表">链表</h2><h3 id="92-反转链表-II">92.反转链表 II</h3><p>Tags: 链表</p><h4 id="题目-3">题目</h4><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p><h4 id="Solution1-3">Solution1</h4><pre><code></code></pre>]]></content>
    
    
    <summary type="html">LeetCode数据结构类题目记录</summary>
    
    
    
    <category term="practice" scheme="https://spike1337.github.io/categories/practice/"/>
    
    
    <category term="C++, Data Structure" scheme="https://spike1337.github.io/tags/C-Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 刷题日记 · 算法</title>
    <link href="https://spike1337.github.io/2023/08/31/leetcode_algorithms/"/>
    <id>https://spike1337.github.io/2023/08/31/leetcode_algorithms/</id>
    <published>2023-08-31T01:05:00.000Z</published>
    <updated>2023-08-31T01:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划">动态规划</h2><h3 id="17-09-面试题-第k个数">17.09 面试题 第k个数</h3><p>Tags: hashtable, 动态规划, 堆</p><h4 id="题目">题目</h4><p><a href="https://leetcode.cn/problems/get-kth-magic-number-lcci/">https://leetcode.cn/problems/get-kth-magic-number-lcci/</a></p><h4 id="Solution1">Solution1</h4><p>使用小顶堆，每次取出堆顶元素<code>x</code>，将<code>3x</code>，<code>5x</code>，<code>7x</code>放入堆中，第k次取出的为目标数。这里需要注意我们存入堆中的数可能大于<code>INT_MAX</code>，需要使用<code>long</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 小顶堆</span></span><br><span class="line">        priority_queue&lt;<span class="type">long</span>, vector&lt;<span class="type">long</span>&gt;, greater&lt;<span class="type">long</span>&gt;&gt; my_heap;</span><br><span class="line">        <span class="comment">// 去重hash表</span></span><br><span class="line">        unordered_set&lt;<span class="type">long</span>&gt; my_hash;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; factors = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ugly = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        my_heap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        my_hash.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">long</span> cur_element = my_heap.<span class="built_in">top</span>();</span><br><span class="line">            my_heap.<span class="built_in">pop</span>();</span><br><span class="line">            ugly = (<span class="type">int</span>) cur_element;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> factor: factors) &#123;</span><br><span class="line">                <span class="type">long</span> next = factor * cur_element;</span><br><span class="line">                <span class="keyword">if</span> (my_hash.<span class="built_in">count</span>(next) == <span class="number">0</span>) &#123;</span><br><span class="line">                    my_hash.<span class="built_in">insert</span>(next);</span><br><span class="line">                    my_heap.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ugly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>缺点：维护堆和hash表时，存储了较多不需要的数，时间复杂度也很高</p></li></ul><h4 id="Solution2">Solution2</h4><p>Solution1的性能上还有很多不足，主要可优化的点在于堆和hash表的维护过程有很多不必要的步骤。主要的冗余步骤在于我们每次循环都将<code>3x</code>，<code>5x</code>和<code>7x</code>三个值都存了进去，如果我们每次只存一个正确的值，就可以优化掉这个性能。</p><p>通过观察我们可以发现，一个丑数一定是在他之前的某个丑数与’3,5,7’中的一个数之积。</p><p>假设有一个数组ugly[n]，其中<strong>从头</strong>存放了一段丑数，那么包含所有丑数数组的数组一定是以下三个数组合并的结果</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="comment">[ugly<span class="comment">[0]</span> * 3, ugly<span class="comment">[1]</span> * 3, ..., ugly<span class="comment">[n]</span> * 3]</span></span><br><span class="line">2. <span class="comment">[ugly<span class="comment">[0]</span> * 5, ugly<span class="comment">[1]</span> * 5, ..., ugly<span class="comment">[n]</span> * 5]</span></span><br><span class="line">3. <span class="comment">[ugly<span class="comment">[0]</span> * 7, ugly<span class="comment">[1]</span> * 7, ..., ugly<span class="comment">[n]</span> * 7]</span></span><br></pre></td></tr></table></figure><p>这道题就变成了合并有序数组的题目，我们使用三个指针分别指向三个数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ugly</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="comment">// 三个指针</span></span><br><span class="line">        <span class="type">int</span> p3 = <span class="number">0</span>, p5 = <span class="number">0</span>, p7 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp_min = <span class="built_in">min</span>(<span class="built_in">min</span>(ugly[p3] * <span class="number">3</span>, ugly[p5] * <span class="number">5</span>), ugly[p7] * <span class="number">7</span>);</span><br><span class="line">            ugly[i] = tmp_min;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ugly[i] == ugly[p3] * <span class="number">3</span>)</span><br><span class="line">                p3++;</span><br><span class="line">            <span class="keyword">if</span> (ugly[i] == ugly[p5] * <span class="number">5</span>)</span><br><span class="line">                p5++;</span><br><span class="line">            <span class="keyword">if</span> (ugly[i] == ugly[p7] * <span class="number">7</span>)</span><br><span class="line">                p7++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ugly[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>优点：优化了性能</p></li></ul><h3 id="53-最大子数组和">53.最大子数组和</h3><p>经典的动态规划问题，<a href="">详解动态规划</a></p><h4 id="题目-2">题目</h4><p><a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p><h4 id="Solution1-2">Solution1</h4><p>nums = [-2,1,-3,4,-1,2,1,-5,4]</p><ol><li class="lvl-3"><p>-2 最大子数组 [-2]</p></li><li class="lvl-4"><p>1 最大子数组 [1]</p></li><li class="lvl-3"><p>-3 最大子数组 [1]</p></li><li class="lvl-4"><p>4 最大子数组 [4]</p></li><li class="lvl-3"><p>-1 最大子数组 [4]</p></li><li class="lvl-4"><p>2 最大子数组 [4, -1, 2]</p></li><li class="lvl-4"><p>1 最大子数组 [4, -1, 2, 1]</p></li><li class="lvl-3"><p>-5 最大子数组 [4, -1, 2, 1]</p></li><li class="lvl-4"><p>4 最大子数组 [4, -1, 2, 1]</p></li></ol><p>观察得到结论，即对于前n个数的最大子数组和<code>f(n)</code>，有<code>f(n) = max(f(n-1) + nums[n], nums[n])</code>，所以我们可以使用动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> pre_array = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">            pre_array = <span class="built_in">max</span>(pre_array + x, x);</span><br><span class="line">            sum = <span class="built_in">max</span>(sum, pre_array);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="55-跳跃游戏">55.跳跃游戏</h3><h4 id="题目-3">题目</h4><p><a href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></p><h4 id="Solution2-2">Solution2</h4><p>nums = [2,3,1,1,4]</p><p>我们设<code>f(i)</code>为前i-1个点能到达的最远距离，那么就有<code>f(n) = max(f(n-1), i + nums[i])</code>，当<code>f(i) &gt; nums.size()</code>时，能够跳到</p><p>f(n)可以优化为一个变量<code>max_distance</code>表示当前能到达的最远距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里用到的是动态规划的空间优化方法，同时包含贪心算法的思想</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前i - 1个点能到达的最远距离</span></span><br><span class="line">        <span class="type">int</span> max_distance = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历，max_distance是能到达的最远距离</span></span><br><span class="line">        <span class="comment">// 如果i &gt; max_distance，说明最远距离不再改变，且没有到末尾元素</span></span><br><span class="line">        <span class="comment">// 这是我们无法跳到终点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= max_distance; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = i + nums[i];</span><br><span class="line">            <span class="comment">// 与第i个点能到达的最远距离比较</span></span><br><span class="line">            max_distance = <span class="built_in">max</span>(tmp, max_distance);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (max_distance &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="45-跳跃游戏-II">45.跳跃游戏 II</h3><h4 id="题目-4">题目</h4><p><a href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></p><h4 id="Solution2-3">Solution2</h4><h2 id="二分查找">二分查找</h2><p>二分查找题目</p><h3 id="35-搜索插入位置">35. 搜索插入位置</h3><h4 id="题目-5">题目</h4><p>Tags: 二分查找</p><p><a href="https://leetcode.cn/problems/search-insert-position/">https://leetcode.cn/problems/search-insert-position/</a></p><h4 id="Solution1-3">Solution1</h4><p>二分查找标准模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[size - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lo = <span class="number">0</span>, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 下面可能会整型溢出</span></span><br><span class="line">            <span class="comment">// mid = (hi + lo) / 2;</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="33-搜索旋转排序数组">33.搜索旋转排序数组</h3><p>Tags: 数组，二分查找</p><h4 id="题目-6">题目</h4><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">https://leetcode.cn/problems/search-in-rotated-sorted-array/</a></p><h4 id="Solution1-4">Solution1</h4><ol><li class="lvl-3"><p>将数组一分为二，一定有一部分是有序的，对有序部分进行二分查找</p></li><li class="lvl-3"><p>如果没有找到目标值，重复步骤1</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// obvious values check</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] == target)</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == target)</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对有序部分进行二分查找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[left]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target &amp;&amp; nums[left] &lt; target)</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[right] &gt; target)</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="34-排序数组查找元素的第一个和最后一个位置">34.排序数组查找元素的第一个和最后一个位置</h3><h4 id="题目-7">题目</h4><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><h4 id="Solution1-5">Solution1</h4><p>找到数组中第一个等于target的下标<code>lo</code>和第一个大于target的下标<code>hi</code>, <code>ans = &#123;lo, hi&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// lower: true 寻找大于等于target的下标, false 寻找第一个大于target的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target, <span class="type">bool</span> lower)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> lo = <span class="number">0</span>, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个等于target的下标</span></span><br><span class="line">        <span class="type">int</span> lo = <span class="built_in">BinarySearch</span>(nums, target, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 第一个大于target的下标 - 1</span></span><br><span class="line">        <span class="type">int</span> hi = <span class="built_in">BinarySearch</span>(nums, target, <span class="literal">false</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lo &lt;= hi &amp;&amp;</span><br><span class="line">            hi &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp;</span><br><span class="line">            nums[lo] == target &amp;&amp;</span><br><span class="line">            nums[hi] == target) &#123;</span><br><span class="line">                ans[<span class="number">0</span>] = lo;</span><br><span class="line">                ans[<span class="number">1</span>] = hi;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="74-搜索二维矩阵">74.搜索二维矩阵</h3><h4 id="题目-8">题目</h4><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></p><h4 id="Solution1-6">Solution1</h4><p>先对每行第一个值做二分查找，确定target可能在哪一行，在对这行做二分查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 两次二分法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界值</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定target可能在哪一行</span></span><br><span class="line">        <span class="type">int</span> lo = <span class="number">0</span>, hi = m - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi &amp;&amp; m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &gt; target)</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;  target)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在目标行内做而二分查找</span></span><br><span class="line">        <span class="type">int</span> row = (m == <span class="number">1</span> ? <span class="number">0</span> : lo - <span class="number">1</span>);</span><br><span class="line">        lo = <span class="number">0</span>, hi = n - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi &amp;&amp; n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][mid] &gt; target)</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][mid] &lt;  target)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界值</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; matrix[row][<span class="number">0</span>] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Solution2-4">Solution2</h4><p>优化Solution1的写法，使用lambda函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 两次二分法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// lambda 函数比较出在哪一行</span></span><br><span class="line">        <span class="keyword">auto</span> row = <span class="built_in">upper_bound</span>(matrix.<span class="built_in">begin</span>(), matrix.<span class="built_in">end</span>(), target,</span><br><span class="line">            [](<span class="type">const</span> <span class="type">int</span> b, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a) &#123;</span><br><span class="line">                <span class="keyword">return</span> b &lt; a[<span class="number">0</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界值</span></span><br><span class="line">        <span class="keyword">if</span> (row == matrix.<span class="built_in">begin</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        --row;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">binary_search</span>(row-&gt;<span class="built_in">begin</span>(), row-&gt;<span class="built_in">end</span>(), target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Solution3">Solution3</h4><p>将矩阵的坐标映射为一维数组的下标，只做一次二分查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 一次二分法，将矩阵坐标映射为一维数组下标</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> lo = <span class="number">0</span>, hi = m * n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="type">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> num = matrix[mid / n][mid % n];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (num &gt; target) &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; target) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="自动机">自动机</h2><h3 id="8-字符串转换整数">8.字符串转换整数</h3><p>Tags: 字符串，自动机</p><h4 id="题目-9">题目</h4><p><a href="https://leetcode.cn/problems/string-to-integer-atoi">https://leetcode.cn/problems/string-to-integer-atoi</a></p><h4 id="Solution1-7">Solution1</h4><p>最直观的遍历字符串方法，根据题目规则判断字符串中的每一个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>;  <span class="comment">// sign flag</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> in_digit_range = <span class="literal">false</span>;  <span class="comment">// we are in digital range</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> element: s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// skip space</span></span><br><span class="line">            <span class="keyword">if</span> (element == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (in_digit_range)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (element == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (in_digit_range)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                sign = <span class="number">-1</span>;</span><br><span class="line">                in_digit_range = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (element == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (in_digit_range)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    in_digit_range = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (element &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; element &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                in_digit_range = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum &gt; INT_MAX / <span class="number">10</span> || (sum == INT_MAX / <span class="number">10</span> &amp;&amp; element &gt; <span class="string">&#x27;7&#x27;</span>))</span><br><span class="line">                    <span class="keyword">return</span> sign &gt; <span class="number">0</span> ? INT_MAX : INT_MIN;</span><br><span class="line"></span><br><span class="line">                sum = sum * <span class="number">10</span> + (element - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign * sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>优点：直观易懂</p></li><li class="lvl-2"><p>缺点：代码臃肿</p></li><li class="lvl-2"><p>结论：正常思路</p></li></ul><h4 id="Solution2-5">Solution2</h4><p>来自LeetCode官方的思路：自动机</p><blockquote><p>我们的程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s’。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s’ 的表格即可解决题目中的问题。</p></blockquote><p><input type="checkbox" id="checkbox2"><label for="checkbox2"> 写一下自动机文档</label></p><p>自动机状态表格：</p><table><thead><tr><th></th><th>’ ’</th><th>+/-</th><th>number</th><th>other</th></tr></thead><tbody><tr><td>start</td><td>start</td><td>signed</td><td>in_number</td><td>end</td></tr><tr><td>signed</td><td>end</td><td>end</td><td>in_number</td><td>end</td></tr><tr><td>in_number</td><td>end</td><td>end</td><td>in_number</td><td>end</td></tr><tr><td>end</td><td>end</td><td>end</td><td>end</td><td>end</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Automaton class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span> &#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>, &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_col</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">get_col</span>(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;in_number&quot;</span>) &#123;</span><br><span class="line">            sum = sum * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            sum = sign == <span class="number">1</span> ? <span class="built_in">min</span>(sum, (<span class="type">long</span> <span class="type">long</span>)INT_MAX) : <span class="built_in">min</span>(sum, -(<span class="type">long</span> <span class="type">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;signed&quot;</span>) &#123;</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: str) &#123;</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>优点：能简单练习下自动机，代码更好看一点</p></li><li class="lvl-2"><p>缺点：逻辑更复杂，性能更慢，内存占用更大</p></li><li class="lvl-2"><p>结论：如果是生产代码，我肯定不会这么写。但是练习算法时还是可以试试的</p></li></ul>]]></content>
    
    
    <summary type="html">LeetCode算法类题目记录</summary>
    
    
    
    <category term="practice" scheme="https://spike1337.github.io/categories/practice/"/>
    
    
    <category term="C++, Algorithm" scheme="https://spike1337.github.io/tags/C-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 刷题日记 · SQL</title>
    <link href="https://spike1337.github.io/2023/08/31/leetcode_sql/"/>
    <id>https://spike1337.github.io/2023/08/31/leetcode_sql/</id>
    <published>2023-08-31T01:05:00.000Z</published>
    <updated>2023-08-31T01:05:00.000Z</updated>
    
    
    <summary type="html">LeetCode数据库类题目记录</summary>
    
    
    
    <category term="practice" scheme="https://spike1337.github.io/categories/practice/"/>
    
    
    <category term="SQL" scheme="https://spike1337.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>我的C++最佳实践原则（持续更新中...</title>
    <link href="https://spike1337.github.io/2023/08/25/my_cxx_best_practice_nodes/"/>
    <id>https://spike1337.github.io/2023/08/25/my_cxx_best_practice_nodes/</id>
    <published>2023-08-25T07:51:00.000Z</published>
    <updated>2023-08-25T07:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>这篇文章算是我在学习现代C++路上中捡到的各种零零散散的知识点的合集，总结在这里方便之后不断地回来翻阅。以项目构建的流程角度分为以下类</p><ul class="lvl-0"><li class="lvl-2"><p>程序测试</p></li><li class="lvl-2"><p>程序设计</p></li><li class="lvl-2"><p>代码实现</p></li></ul><p>这些原则的来源包括但不限于：</p><ul class="lvl-0"><li class="lvl-2"><p>Jason Turner大佬的《C++ Best Practices: 45ish Simple Rules with Specific Action Items for Better C++》</p></li><li class="lvl-2"><p>Pengba大佬的<a href="http://mindhacks.cn/2012/08/27/modern-cpp-practices/">C<ins>11（及现代C</ins>风格）和快速迭代式开发 </a></p></li><li class="lvl-2"><p>自己的一些总结</p></li><li class="lvl-2"><p>…</p></li></ul><p>汇总到一起作为本人开发是参考的小抄，方便查阅</p><blockquote><p>PS: 有关C++语法的奇技淫巧和最佳实践，我都是统一参考<a href="google-styleguide.googlecode.com">Google Style Guide</a>，就不在这里做copy paste了</p></blockquote><h1>程序测试</h1><h2 id="自动测试框架">自动测试框架</h2><p>我们的代码首先要具备的就是一个自动测试框架，它要包含基于实现逻辑的单元测试，以及基于用户行为的BDD回归测试。一个好的自动测试可以让我们放心的重构代码、扩展代码。从另一个方面来说，如何测试很难构建，那么这段代码的设计很可能并不是最优的</p><h2 id="持续构建测试">持续构建测试</h2><p>我们需要一些持续构建的自动测试工具来帮助我们确保每一次提交的可靠性，不管是gitlab的ci，还是github的workflow，或者其他的持续构建工具。</p><h2 id="编译器警告">编译器警告</h2><p>我们需要编译器来告诉我们，我们的代码是否正确符合C++标准。注意<code>-Wall</code>并不是GCC和Clang提供的所有warning，<code>-Wextra</code>能提供更多的信息，但还是建议使用<code>-Wpedantic</code>获取gcc/clang提供的以ANSI/ISO C标准列出的警告</p><h2 id="静态分析">静态分析</h2><p>静态分析是我们构建代码的第一道防线。现在有许多免费开源的静态分析工具，其中推荐CPPCHECK和clang-tidy</p><h2 id="使用-Sanitizers">使用 Sanitizers</h2><p>Sanitizers是一个运行时分析工具，推荐在开发时永远开启Address sanitiz和UB Sanitizer，在包含多线程时开启Thread sanitizer</p><h2 id="模糊测试-Fuzzing-和变异测试-Mutating">模糊测试(Fuzzing)和变异测试(Mutating)</h2><p>我们开发人员设计的测试用例往往是带有思维惯性的，对于有些极端或误用的情况测试不到，这是我们需要这些工具来弥补我们的思维惯性</p><h3 id="Fuzzing">Fuzzing</h3><p>模糊测试工具能够生成各种长度的随机字符串，这种测试能够约束你用合适的方法去处理这些数据，模糊测试工具分析那些从你的测试执行过程中生成出来的覆盖率数据并且使用那些信息去删除多余的测试并且产生新且特殊的测试用例。</p><p>对于C++，我们可以使用American Fuzzy Lop（AFL）来进行模糊测试</p><h3 id="Mutating">Mutating</h3><p>编译测试通过修改你的代码来完成测试。它修改你的代码逻辑，之后任何能通过的测试用例都意味着要么你的代码存在bug，要么测试用例有缺陷。</p><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterThanFive</span><span class="params">(<span class="type">const</span> <span class="type">int</span> value)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">5</span>; <span class="comment">// comparison</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tests</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">greaterThanFive</span>(<span class="number">6</span>));</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">greaterThanFive</span>(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变异测试会修改你的代码如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterThanFive</span><span class="params">(<span class="type">const</span> <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &lt; <span class="number">5</span>; <span class="comment">// mutated</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>程序设计</h1><h2 id="KISS原则">KISS原则</h2><p>这是一个已经被说烂了的元组原则，不做不必要的实现，是你的代码尽可能简洁、简单的完成。但我想说KISS不仅是用在程序逻辑的实现中，更应该用在设计层面上。一个好的设计能让你的代码少走20年弯路，使其以一个好的代码质量开头，这无疑对之后的维护和扩展是更有帮助的。</p><h2 id="持续重构">持续重构</h2><p>当然我们并不是全知全能，我们在项目开始迭代之后也一定有层出不穷的奇妙想法，可能是在某天睡梦中你对某个feature有了更好的设计方案，这时不要害怕去重构代码，在保证有完备的测试体系下，不断地去重构代码，这能有效的阻止随着代码增长带来的技术债滚雪球似的堆积。</p><h2 id="copy-paste">copy paste</h2><p>当你在copy paste时，想想是否可以抽象为一个函数，或者一个模板？</p><h1>代码实现</h1><h2 id="用const修饰一切常量">用const修饰一切常量</h2><p>如果形参在函数内部不会有修改的行为，将形参也声明为<code>const</code></p><h2 id="善用constexpr">善用constexpr</h2><p>如果一个常量值在编译时已经可以得到，使用<code>constexpr</code>。不要让<code>#define</code>成为你的默认选择</p><h2 id="多使用auto">多使用auto</h2><p><code>auto</code>在泛型编程时可以极大的简化我们的代码，不要在花费功夫去看这个返回值应该是什么类型了</p><h2 id="range-for循环">range-for循环</h2><p>对容器进行遍历时，使用range-for循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;element : container) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是不要在range-for循环时修改容器自身，如果需要修改，使用老办法吧</strong></p><h2 id="善用STL算法">善用STL算法</h2><p>一个场景：检查一个容器内是否有大于42的数</p><p>使用循环，我们需要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> has_value;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;element : container) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element &gt; <span class="number">42</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        has_value = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> has_value = std::<span class="built_in">any_of</span>(<span class="built_in">begin</span>(container), <span class="built_in">end</span>(container), <span class="built_in">greater_than</span>(<span class="number">12</span>));</span><br></pre></td></tr></table></figure><p><strong>使用算法在某些场景下可能会使你的代码没有那么易读，根据场景使用它</strong></p><h2 id="使用模板">使用模板</h2><p>模板时DRY（Dont repeat yourself）原则的典型设计，不要害怕去使用它。</p><p>当然，使用模板时，给你的类型一个更有意义的名字，而不是用<code>T</code></p><h2 id="使用智能指针">使用智能指针</h2><p>尽量避免使用new，在使用到堆的情况下，使用<code>std::make_unique&lt;&gt;()</code>和<code>std::make_shared&lt;&gt;()</code>来确保安全的资源管理</p><h2 id="跳过C-11">跳过C++11</h2><p>如果你在正在转向”现代C++&quot;, 请跳过Cpp11版本, Cpp14修复了许多Cpp11的漏洞。</p><p>其中语言层面的特性包括：</p><ol><li class="lvl-3"><p>C<ins>11 版本的constexpr 隐式地指定了所有成员函数为const(即不能修改this)， 这在C</ins>14已经被改变。</p></li><li class="lvl-3"><p>C++11缺少对函数对auto 返回类型的推导(lambdas有)</p></li><li class="lvl-3"><p>C++11没有auto或者可变Lambda参数的</p></li><li class="lvl-3"><p>C++14新增[[deprecated]]特性</p></li><li class="lvl-3"><p>C++14新增了数字分隔符， 比如1’000’000</p></li><li class="lvl-3"><p>在C++14里constexpr 函数可以有多个return</p></li></ol><p>库层面特性包括：</p><ol><li class="lvl-3"><p>std::make_unique 在C++14中加入</p></li><li class="lvl-3"><p>C++11没有std::exchange</p></li><li class="lvl-3"><p>C++14新增了对std::array的constexpr支持</p></li><li class="lvl-3"><p>cbegin, cend, crbegin, 和crend 这些自由函数(free function ,没有入参的函数） 为了和begin 和end这些在C++11加入的标准容器中的自由函数保持一致而被加入了。</p></li></ol>]]></content>
    
    
    <summary type="html">C++ Best Practice Principle</summary>
    
    
    
    <category term="C++" scheme="https://spike1337.github.io/categories/C/"/>
    
    
    <category term="C++, develop" scheme="https://spike1337.github.io/tags/C-develop/"/>
    
  </entry>
  
  <entry>
    <title>Butterfly主题Markdown样式测试</title>
    <link href="https://spike1337.github.io/2023/08/22/butterfly-test/"/>
    <id>https://spike1337.github.io/2023/08/22/butterfly-test/</id>
    <published>2023-08-22T06:37:00.000Z</published>
    <updated>2023-08-24T02:42:44.534Z</updated>
    
    <content type="html"><![CDATA[<h1>H1标题</h1><p>这是一些文字样式。</p><p>Here are some text styles.</p><h2 id="H2标题">H2标题</h2><h3 id="H3标题">H3标题</h3><h4 id="H4标题">H4标题</h4><p><em>斜体</em></p><p><strong>粗体</strong></p><h3 id="代码">代码</h3><p>行内代码 <code>rm -rf /root/</code></p><p>代码高亮</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_text</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; n:</span><br><span class="line">        <span class="built_in">print</span>(a, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">fib(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FooBar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name_path[<span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表格">表格</h3><table><thead><tr><th>key</th><th>value</th><th>comment</th></tr></thead><tbody><tr><td>key1</td><td>value1</td><td>comment1</td></tr><tr><td>key2</td><td>value2</td><td>comment2</td></tr><tr><td>key3</td><td>value3</td><td>comment3</td></tr></tbody></table><h3 id="列表">列表</h3><h4 id="有序列表">有序列表</h4><ol><li class="lvl-3"><p>comment1</p></li><li class="lvl-3"><p>comment2</p></li><li class="lvl-3"><p>comment3</p></li></ol><h4 id="无序列表">无序列表</h4><ul class="lvl-0"><li class="lvl-2"><p>function1</p></li><li class="lvl-2"><p>function2</p><ul class="lvl-2"><li class="lvl-6">function3</li></ul></li><li class="lvl-2"><p>function4</p></li></ul><h3 id="图片">图片</h3><p><img src="/img/csgo1.png" alt="这是一张图片"></p><h3 id="勾选框">勾选框</h3><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox0"><label for="checkbox0"> todo 1</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1"> todo 2</label></p></li></ul><h3 id="emoji">emoji</h3><p>😢 这是个很重要的功能！</p>]]></content>
    
    
    <summary type="html">一个测试Butterfly主题对于markdown样式解析的测试demo</summary>
    
    
    
    <category term="demo" scheme="https://spike1337.github.io/categories/demo/"/>
    
    
    <category term="demo" scheme="https://spike1337.github.io/tags/demo/"/>
    
  </entry>
  
  <entry>
    <title>C标准库 · 文件访问 · statx</title>
    <link href="https://spike1337.github.io/2023/07/25/statx/"/>
    <id>https://spike1337.github.io/2023/07/25/statx/</id>
    <published>2023-07-25T06:41:21.000Z</published>
    <updated>2023-08-22T01:36:55.571Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发遇到一个问题，想要获取某个文件毫秒级的修改时间。众所周知C标准库中提供的<code>stat</code>函数只能获取到秒级的修改时间<code>st_mtime</code>。相关的信息翻了个遍，最终还是神奇的ChatGPT给我了答案：</p><p>Linux 4.11及更高版本，支持<code>statx</code>提供了毫秒级的文件修改时间</p><h2 id="SYNOPSIS">SYNOPSIS</h2><p><strong>STRUCT</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">statx</span> &#123;</span><br><span class="line">    __u32 stx_mask;        <span class="comment">/* Mask of bits indicating</span></span><br><span class="line"><span class="comment">                                filled fields */</span></span><br><span class="line">    __u32 stx_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">    __u64 stx_attributes;  <span class="comment">/* Extra file attribute indicators */</span></span><br><span class="line">    __u32 stx_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">    __u32 stx_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">    __u32 stx_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    __u16 stx_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">    __u64 stx_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">    __u64 stx_size;        <span class="comment">/* Total size in bytes */</span></span><br><span class="line">    __u64 stx_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line">    __u64 stx_attributes_mask;</span><br><span class="line">                            <span class="comment">/* Mask to show what&#x27;s supported</span></span><br><span class="line"><span class="comment">                                in stx_attributes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields are file timestamps */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">statx_timestamp</span> stx_atime;  <span class="comment">/* Last access */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">statx_timestamp</span> stx_btime;  <span class="comment">/* Creation */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">statx_timestamp</span> stx_ctime;  <span class="comment">/* Last status change */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">statx_timestamp</span> stx_mtime;  <span class="comment">/* Last modification */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this file represents a device, then the next two</span></span><br><span class="line"><span class="comment">        fields contain the ID of the device */</span></span><br><span class="line">    __u32 stx_rdev_major;  <span class="comment">/* Major ID */</span></span><br><span class="line">    __u32 stx_rdev_minor;  <span class="comment">/* Minor ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The next two fields contain the ID of the device</span></span><br><span class="line"><span class="comment">        containing the filesystem where the file resides */</span></span><br><span class="line">    __u32 stx_dev_major;   <span class="comment">/* Major ID */</span></span><br><span class="line">    __u32 stx_dev_minor;   <span class="comment">/* Minor ID */</span></span><br><span class="line"></span><br><span class="line">    __u64 stx_mnt_id;      <span class="comment">/* Mount ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Direct I/O alignment restrictions */</span></span><br><span class="line">    __u32 stx_dio_mem_align;</span><br><span class="line">    __u32 stx_dio_offset_align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中四个<code>statx_timestamp</code>就是我们需要的毫秒级时间戳</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">statx_timestamp</span> &#123;</span><br><span class="line">    __s64   tv_sec;      <span class="comment">// 秒数时间戳</span></span><br><span class="line">    __u32   tv_nsec;     <span class="comment">// tv_srchi周的纳秒数</span></span><br><span class="line">    __s32   __reserved;  <span class="comment">// 保留精度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>FUNCTION</strong></p><p>函数statx位于C标准库 Standard C library (libc, -lc)，函数的声明和使用如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">statx</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *restrict pathname, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">unsigned</span> <span class="type">int</span> mask, <span class="keyword">struct</span> statx *restrict statxbuf)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>RETURN</strong></p><p>如果执行成功，返回0，否则返回-1并设置errno</p><p>更详细的信息请移步 <a href="https://man7.org/linux/man-pages/man2/statx.2.html">LINUX MANUAL PAGE</a></p><h2 id="Example">Example</h2><p>我自己测试的一个简单例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;tmp_file&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// statx 结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">statx</span> buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AT_FDCWD    在当前目录下运行</span></span><br><span class="line">    <span class="comment">// STATX_MTIME 获取修改时间</span></span><br><span class="line">    <span class="comment">// AT_SYMLINK_NOFOLLOW 如果是链接则返回链接本身信息</span></span><br><span class="line">    <span class="type">int</span> result =</span><br><span class="line">        <span class="built_in">statx</span>(AT_FDCWD, filename, AT_SYMLINK_NOFOLLOW, STATX_MTIME, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: %m\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer.stx_mtime 记录文件的最后修改时间</span></span><br><span class="line">    <span class="comment">// tv_sec 是秒级, tv_nsec 是毫秒级</span></span><br><span class="line">    <span class="type">int64_t</span> sec = buffer.stx_mtime.tv_sec;</span><br><span class="line">    <span class="type">int</span>     micro_sec = buffer.stx_mtime.tv_nsec / <span class="number">1000</span>;</span><br><span class="line">    <span class="type">char</span>    time_str[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strftime</span>(time_str, <span class="number">128</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, <span class="built_in">localtime</span>(&amp;sec));</span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Modification time of file %s is %s.%d\n&quot;</span>, filename,</span><br><span class="line">        time_str, micro_sec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux测试用例</p><p><a href="https://kgithub.com/torvalds/linux/blob/master/samples/vfs/test-statx.c">https://kgithub.com/torvalds/linux/blob/master/samples/vfs/test-statx.c</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开发遇到一个问题，想要获取某个文件毫秒级的修改时间。众所周知C标准库中提供的&lt;code&gt;stat&lt;/code&gt;函数只能获取到秒级的修改时间&lt;code&gt;st_mtime&lt;/code&gt;。相关的信息翻了个遍，最终还是神奇的ChatGPT给我了答案：&lt;/p&gt;
&lt;p&gt;Linux </summary>
      
    
    
    
    <category term="Linux" scheme="https://spike1337.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://spike1337.github.io/tags/Linux/"/>
    
    <category term="libc" scheme="https://spike1337.github.io/tags/libc/"/>
    
    <category term="file access" scheme="https://spike1337.github.io/tags/file-access/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL源码 · 元组管理（三）· 元组的插入</title>
    <link href="https://spike1337.github.io/2023/07/13/tuple_insert/"/>
    <id>https://spike1337.github.io/2023/07/13/tuple_insert/</id>
    <published>2023-07-13T11:02:08.000Z</published>
    <updated>2023-08-24T01:54:58.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="元组插入">元组插入</h2><p>元组的插入主要由函数<code>heap_insert</code>来完成，主要分为几步：</p><ol><li class="lvl-3"><p>初始化元组头 HeapTupleHeader</p></li><li class="lvl-3"><p>获取可用的page</p></li><li class="lvl-3"><p>判断元组可见性和事务冲突</p></li><li class="lvl-3"><p>将元组写入可用的page，并标记page dirty</p></li><li class="lvl-3"><p>写wal</p></li></ol><h3 id="初始化元组的元数据">初始化元组的元数据</h3><p>在<code>heap_prepare_insert</code>中完成，接口比较简单，我们直接来看源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> HeapTuple</span></span><br><span class="line"><span class="function"><span class="title">heap_prepare_insert</span><span class="params">(Relation relation, HeapTuple tup, TransactionId xid,</span></span></span><br><span class="line"><span class="params"><span class="function">                    CommandId cid, <span class="type">int</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 计算元组的infomask &amp; infomask2 */</span></span><br><span class="line">    tup-&gt;t_data-&gt;t_infomask &amp;= ~(HEAP_XACT_MASK);</span><br><span class="line">    tup-&gt;t_data-&gt;t_infomask2 &amp;= ~(HEAP2_XACT_MASK);</span><br><span class="line">    tup-&gt;t_data-&gt;t_infomask |= HEAP_XMAX_INVALID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置xmin，也就是元组插入的事务号 */</span></span><br><span class="line">    <span class="built_in">HeapTupleHeaderSetXmin</span>(tup-&gt;t_data, xid);</span><br><span class="line">    <span class="keyword">if</span> (options &amp; HEAP_INSERT_FROZEN)</span><br><span class="line">        <span class="built_in">HeapTupleHeaderSetXminFrozen</span>(tup-&gt;t_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置cid、xmax和tableoid，由于是元组插入，则将xmax设置为0 */</span></span><br><span class="line">    <span class="built_in">HeapTupleHeaderSetCmin</span>(tup-&gt;t_data, cid);</span><br><span class="line">    <span class="built_in">HeapTupleHeaderSetXmax</span>(tup-&gt;t_data, <span class="number">0</span>);</span><br><span class="line">    tup-&gt;t_tableOid = <span class="built_in">RelationGetRelid</span>(relation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断是否为TOAST元组 */</span></span><br><span class="line">    <span class="keyword">if</span> (relation-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;</span><br><span class="line">        relation-&gt;rd_rel-&gt;relkind != RELKIND_MATVIEW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Assert</span>(!<span class="built_in">HeapTupleHasExternal</span>(tup));</span><br><span class="line">        <span class="keyword">return</span> tup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">HeapTupleHasExternal</span>(tup) || tup-&gt;t_len &gt; TOAST_TUPLE_THRESHOLD)</span><br><span class="line">        <span class="comment">/* TOAST元组，调用相应的插入接口 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">heap_toast_insert_or_update</span>(relation, tup, <span class="literal">NULL</span>, options);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* 否则直接返回准备好的tup */</span></span><br><span class="line">        <span class="keyword">return</span> tup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取可用的page">获取可用的page</h3><p>在<code>RelationGetBufferForTuple</code>中完成。</p><p>relation是目标表对象，len是tuple插入需要的长度。otherBuffer用于元组update时替换旧的buffer，options是写入的选项，bistate表示批量插入对象的状态，vmbuffer和vmbuffer_other用于可见性映射</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Buffer</span></span><br><span class="line"><span class="function"><span class="title">RelationGetBufferForTuple</span><span class="params">(Relation relation, Size len,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Buffer otherBuffer, <span class="type">int</span> options,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BulkInsertState bistate,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Buffer *vmbuffer, Buffer *vmbuffer_other)</span></span></span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p>通过填充因子，计算空闲空间。</p></li></ol><p>填充因子<code>FillFactor</code>是一个百分比，限制了我们对于page的使用率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用了默认填充百分比, HEAP_DEFAULT_FILLFACTOR = 100, 也就是完全填充</span></span><br><span class="line">saveFreeSpace = <span class="built_in">RelationGetTargetPageFreeSpace</span>(relation, HEAP_DEFAULT_FILLFACTOR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有tuple的page中也可能有line pointer，所以使用一个近似值</span></span><br><span class="line">nearlyEmptyFreeSpace = MaxHeapTupleSize -</span><br><span class="line">    (MaxHeapTuplesPerPage / <span class="number">8</span> * <span class="built_in">sizeof</span>(ItemIdData));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len + saveFreeSpace &gt; nearlyEmptyFreeSpace)</span><br><span class="line">    targetFreeSpace = <span class="built_in">Max</span>(len, nearlyEmptyFreeSpace);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    targetFreeSpace = len + saveFreeSpace;</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>尝试从cache中获取表最近使用的page，如果没有则尝试通过FSM获取满足插入条件的page</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bistate &amp;&amp; bistate-&gt;current_buf != InvalidBuffer)</span><br><span class="line">    targetBlock = <span class="built_in">BufferGetBlockNumber</span>(bistate-&gt;current_buf);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    targetBlock = <span class="built_in">RelationGetTargetBlock</span>(relation);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (targetBlock == InvalidBlockNumber &amp;&amp; use_fsm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// cache中没有目标page，让FSM来提供一个初始目标page</span></span><br><span class="line">    targetBlock = <span class="built_in">GetPageWithFreeSpace</span>(relation, targetFreeSpace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>接下来我们拿着之前获取到的block，去获取对应的buffer</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherBuffer == InvalidBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有otherbuffer, 简单插入语句, 获取buffer</span></span><br><span class="line">    buffer = <span class="built_in">ReadBufferBI</span>(relation, targetBlock, RBM_NORMAL, bistate);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PageIsAllVisible</span>(<span class="built_in">BufferGetPage</span>(buffer)))</span><br><span class="line">        <span class="built_in">visibilitymap_pin</span>(relation, targetBlock, vmbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((options &amp; HEAP_INSERT_FROZEN) &amp;&amp;</span><br><span class="line">        (<span class="built_in">PageGetMaxOffsetNumber</span>(<span class="built_in">BufferGetPage</span>(buffer)) == <span class="number">0</span>))</span><br><span class="line">        <span class="built_in">visibilitymap_pin</span>(relation, targetBlock, vmbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LockBuffer</span>(buffer, BUFFER_LOCK_EXCLUSIVE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page = <span class="built_in">BufferGetPage</span>(buffer);</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果拿到的page有足够的空闲空间，我们就完成了获取可用page的步骤，直接返回就可以了</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查page是否有足够的空闲空间，如果有则返回当前page</span></span><br><span class="line">pageFreeSpace = <span class="built_in">PageGetHeapFreeSpace</span>(page);</span><br><span class="line"><span class="keyword">if</span> (targetFreeSpace &lt;= pageFreeSpace)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* use this page as future insert target, too */</span></span><br><span class="line">    <span class="built_in">RelationSetTargetBlock</span>(relation, targetBlock);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果没有足够的空间，我们需要去寻找下一个block</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有正在进行的批量操作, 则还有其他的未使用的page, 我们尝试使用下一个page</span></span><br><span class="line"><span class="keyword">if</span> (bistate &amp;&amp; bistate-&gt;next_free != InvalidBlockNumber)</span><br><span class="line">&#123;</span><br><span class="line">    targetBlock = bistate-&gt;next_free;</span><br><span class="line">    <span class="keyword">if</span> (bistate-&gt;next_free &gt;= bistate-&gt;last_free)</span><br><span class="line">    &#123;</span><br><span class="line">        bistate-&gt;next_free = InvalidBlockNumber;</span><br><span class="line">        bistate-&gt;last_free = InvalidBlockNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        bistate-&gt;next_free++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有进行批量操作, 这个时候就要问一问FSM的意见</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!use_fsm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有FSM, 只能跳出循环去扩页</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过FSM寻找下一个合适的page</span></span><br><span class="line">    targetBlock = <span class="built_in">RecordAndGetPageWithFreeSpace</span>(relation,</span><br><span class="line">                                                targetBlock,</span><br><span class="line">                                                pageFreeSpace,</span><br><span class="line">                                                targetFreeSpace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p>如果以上循环中没有找到空闲buffer，我们只能进入扩页的逻辑来新增一个page用来插入</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩页并返回新增的page, 扩页的具体逻辑我们在这就不详细介绍了</span></span><br><span class="line"><span class="comment">// 简单来说就是给relation加Exclusive锁, 然后初始化一个新的page进去</span></span><br><span class="line">buffer = <span class="built_in">RelationAddBlocks</span>(relation, bistate, num_pages, use_fsm,</span><br><span class="line">                           &amp;unlockedTargetBuffer);</span><br><span class="line"></span><br><span class="line">targetBlock = <span class="built_in">BufferGetBlockNumber</span>(buffer);</span><br><span class="line">page = <span class="built_in">BufferGetPage</span>(buffer);</span><br></pre></td></tr></table></figure><ol start="5"><li class="lvl-3"><p>新增的页我们再来检查下是否有足够的空闲空间，如果有的话就能返回使用了</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pageFreeSpace = <span class="built_in">PageGetHeapFreeSpace</span>(page);</span><br><span class="line"><span class="keyword">if</span> (len &gt; pageFreeSpace)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlockedTargetBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (otherBuffer != InvalidBuffer)</span><br><span class="line">            <span class="built_in">LockBuffer</span>(otherBuffer, BUFFER_LOCK_UNLOCK);</span><br><span class="line">        <span class="built_in">UnlockReleaseBuffer</span>(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">elog</span>(PANIC, <span class="string">&quot;tuple is too big: size %zu&quot;</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RelationSetTargetBlock</span>(relation, targetBlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buffer;</span><br></pre></td></tr></table></figure><h3 id="写入数据">写入数据</h3><p>写入数据是由接口<code>RelationPutHeapTuple</code>来完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">RelationPutHeapTuple</span><span class="params">(Relation relation,</span></span></span><br><span class="line"><span class="params"><span class="function">                     Buffer buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                     HeapTuple tuple,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">bool</span> token)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Page        pageHeader;</span><br><span class="line">    OffsetNumber offnum;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    pageHeader = <span class="built_in">BufferGetPage</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元组插入到page中</span></span><br><span class="line">    offnum = <span class="built_in">PageAddItem</span>(pageHeader, (Item) tuple-&gt;t_data,</span><br><span class="line">                            tuple-&gt;t_len, InvalidOffsetNumber, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前的位置到元组的t_self中</span></span><br><span class="line">    <span class="built_in">ItemPointerSet</span>(&amp;(tuple-&gt;t_self), <span class="built_in">BufferGetBlockNumber</span>(buffer), offnum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前的位置也记录到元组的ctid中</span></span><br><span class="line">    <span class="keyword">if</span> (!token)</span><br><span class="line">    &#123;</span><br><span class="line">        ItemId        itemId = <span class="built_in">PageGetItemId</span>(pageHeader, offnum);</span><br><span class="line">        HeapTupleHeader item = (HeapTupleHeader) <span class="built_in">PageGetItem</span>(pageHeader, itemId);</span><br><span class="line"></span><br><span class="line">        item-&gt;t_ctid = tuple-&gt;t_self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要的工作都有函数<code>PageAddItem</code>来完成，<code>PageAddItem</code>是一个宏，内部调用<code>PageAddItemExtended</code>，我们来详细看下这个接口</p><p>page是插入的页面，item的插入的数据指针，size的插入数据的大小。offsetNumber是元组在页面中的偏移量，如果插入成功则会被返回。flags是插入的选项</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OffsetNumber</span></span><br><span class="line"><span class="function"><span class="title">PageAddItemExtended</span><span class="params">(Page page,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Item item,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Size size,</span></span></span><br><span class="line"><span class="params"><span class="function">                    OffsetNumber offsetNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> flags)</span></span></span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p>首先我们在page中寻找下一个slot的位置，如果之后没有找到空余的slot，我们就会使用这个位置来插入元组</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">limit = <span class="built_in">OffsetNumberNext</span>(<span class="built_in">PageGetMaxOffsetNumber</span>(page));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果page有free line pointer, 也就是pd_flags中包含PD_HAS_FREE_LINES标记</span></span><br><span class="line"><span class="comment">// 则去行指针数组中寻找free slot</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">PageHasFreeLinePointers</span>(page))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 扫描PageHeader的行指针数组，查找标记为 LP_UNUSED的 itemId</span></span><br><span class="line">    <span class="keyword">for</span> (offsetNumber = FirstOffsetNumber;</span><br><span class="line">            offsetNumber &lt; limit;</span><br><span class="line">            offsetNumber++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ItemIdIsUsed</span>(itemId) &amp;&amp; !<span class="built_in">ItemIdHasStorage</span>(itemId))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有free line pointer, 使用limit</span></span><br><span class="line">    offsetNumber = limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>接下来我们计算page的pd_lower和pg_upper指针指向的offset</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (offsetNumber == limit || needshuffle)</span><br><span class="line">    lower = phdr-&gt;pd_lower + <span class="built_in">sizeof</span>(ItemIdData);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    lower = phdr-&gt;pd_lower;</span><br><span class="line"></span><br><span class="line">alignedSize = <span class="built_in">MAXALIGN</span>(size);</span><br><span class="line"></span><br><span class="line">upper = (<span class="type">int</span>) phdr-&gt;pd_upper - (<span class="type">int</span>) alignedSize;</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>最后我们就可以把元组插入到page中了</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果已经有了对应的行指针, 则重新设置行指针中的值和标记</span></span><br><span class="line">itemId = <span class="built_in">PageGetItemId</span>(page, offsetNumber);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needshuffle)</span><br><span class="line">    <span class="built_in">memmove</span>(itemId + <span class="number">1</span>, itemId,</span><br><span class="line">            (limit - offsetNumber) * <span class="built_in">sizeof</span>(ItemIdData));</span><br><span class="line"></span><br><span class="line"><span class="built_in">ItemIdSetNormal</span>(itemId, upper, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据插入到对应的offset</span></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">char</span> *) page + upper, item, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新PageHeader中的upper和lower指针</span></span><br><span class="line">phdr-&gt;pd_lower = (LocationIndex) lower;</span><br><span class="line">phdr-&gt;pd_upper = (LocationIndex) upper;</span><br></pre></td></tr></table></figure><p>###WAL log和统计信息</p><p>将元组真正插入到page之后，我们会写WAL log并更新相关的统计信息。这两块我们就不在这里详细的描述了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;元组插入&quot;&gt;元组插入&lt;/h2&gt;
&lt;p&gt;元组的插入主要由函数&lt;code&gt;heap_insert&lt;/code&gt;来完成，主要分为几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li class=&quot;lvl-3&quot;&gt;
&lt;p&gt;初始化元组头 HeapTupleHeader&lt;/p&gt;
&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/tags/PostgreSQL/"/>
    
    <category term="storage" scheme="https://spike1337.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL源码 · 元组管理（二）· 元组的组织结构</title>
    <link href="https://spike1337.github.io/2023/07/11/tuple_manager_2/"/>
    <id>https://spike1337.github.io/2023/07/11/tuple_manager_2/</id>
    <published>2023-07-11T10:35:06.000Z</published>
    <updated>2023-08-24T01:55:05.462Z</updated>
    
    <content type="html"><![CDATA[<p>上次我们简单看了下PostgreSQL中页面的组织结构，介绍了PageHeader和行指针的结构。这次我们来看看元组的结构，也就是tuple的<code>成员变量</code></p><h2 id="Tuple的结构">Tuple的结构</h2><p>元组的结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint32          t_len;</span><br><span class="line">    ItemPointerData t_self;</span><br><span class="line">    Oid             t_tableOid;</span><br><span class="line">    HeapTupleHeader t_data;</span><br><span class="line">&#125; HeapTupleData;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>t_len</code>，元组<code>t_data</code>字段的长度</p></li><li class="lvl-2"><p><code>t_self</code>，记录元组自己的位置信息，包括所在的block信息，和元组在页面中的offset</p></li><li class="lvl-2"><p><code>t_tableOid</code>，元组所在表的oid</p></li><li class="lvl-2"><p><code>t_data</code>，元组的元数据信息和具体存储的数据</p></li></ul><h3 id="HeapTupleHeader">HeapTupleHeader</h3><p>存储元组的元数据信息，结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        HeapTupleFields     t_heap;</span><br><span class="line">        DatumTupleFields    t_datum;</span><br><span class="line">    &#125; t_choice;</span><br><span class="line"></span><br><span class="line">    ItemPointerData t_ctid;</span><br><span class="line">    uint16      t_infomask2;</span><br><span class="line">    uint16      t_infomask;</span><br><span class="line">    uint8       t_hoff;</span><br><span class="line">    bits8       t_bits[FLEXIBLE_ARRAY_MEMBER];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>t_heap</code>，元组事务相关的域</p></li><li class="lvl-2"><p><code>t_datum</code>，元组数据相关的域</p></li><li class="lvl-2"><p><code>t_cid</code>，HOT元组会指向最新的元组位置，否则指向自己的位置</p></li><li class="lvl-2"><p><code>t_infomask2</code>，元组的属性数，和一些标记位</p></li><li class="lvl-2"><p><code>t_infomask</code>，元组的标记位。这些标记我们就不在这里介绍了</p></li><li class="lvl-2"><p><code>t_hoff</code>，header的整体大小</p></li><li class="lvl-2"><p><code>t_bits</code>，NULL值列的数组</p></li></ul><p><code>t_bits</code>数组之后存放的就是元组的数据</p><h4 id="HeapTupleFields">HeapTupleFields</h4><p>元组事务相关的域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleFields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TransactionId t_xmin;</span><br><span class="line">    TransactionId t_xmax;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        CommandId       t_cid;</span><br><span class="line">        TransactionId   t_xvac;</span><br><span class="line">    &#125; t_field3;</span><br><span class="line">&#125; HeapTupleFields;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>t_xmin</code>，元组插入的事务号</p></li><li class="lvl-2"><p><code>t_xmax</code>，元组删除的事务号</p></li><li class="lvl-2"><p><code>t_cid</code>，命令id，表示当前事务中执行的修改该元组的命令的id</p></li><li class="lvl-2"><p><code>t_xvac</code>，vacuum full操作的事务号</p></li></ul><h4 id="DatumTupleFields">DatumTupleFields</h4><p>元组数据相关的域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DatumTupleFields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    int32datum_len_;<span class="comment">/* varlena header (do not touch directly!) */</span></span><br><span class="line">    int32datum_typmod;<span class="comment">/* -1, or identifier of a record type */</span></span><br><span class="line">    Oiddatum_typeid;<span class="comment">/* composite type OID, or RECORDOID */</span></span><br><span class="line"></span><br><span class="line">&#125; DatumTupleFields;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>datum_len_</code>，变长数据类型的长度</p></li><li class="lvl-2"><p><code>datum_typmod</code>，数据类型</p></li><li class="lvl-2"><p><code>datum_typeid</code>，复合类型的类型oid</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上次我们简单看了下PostgreSQL中页面的组织结构，介绍了PageHeader和行指针的结构。这次我们来看看元组的结构，也就是tuple的&lt;code&gt;成员变量&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;Tuple的结构&quot;&gt;Tuple的结构&lt;/h2&gt;
&lt;p&gt;元组的结构如下&lt;/</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/tags/PostgreSQL/"/>
    
    <category term="storage" scheme="https://spike1337.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL源码 · 元组管理（一）· 页的组织结构</title>
    <link href="https://spike1337.github.io/2023/07/10/tuple_manager_1/"/>
    <id>https://spike1337.github.io/2023/07/10/tuple_manager_1/</id>
    <published>2023-07-10T09:47:33.000Z</published>
    <updated>2023-08-24T01:55:01.531Z</updated>
    
    <content type="html"><![CDATA[<p>开个新坑，简单写一写PostgreSQL中的元组管理。</p><p>对于整个存储架构，各种PostgreSQL的相关书籍已经介绍的很详细了，这里也就不再重复造轮子了。下面我们主要基于面向对象（大雾），来看看元组这个对象，有哪些<code>成员变量</code>，又有哪些<code>成员函数</code></p><hr><p>元组(Tuple)是PostgreSQL中数据的基本存储单元，Page又是存储元组的基本载体，所以这第一篇我们先来看一下Page的结构</p><h2 id="Page的结构">Page的结构</h2><p>Page的结构可以简单看下图所示</p><p><img src="/uploads/page_struct.png" alt="img"></p><p>page的默认大小为8k。每个页面的起始位置有大小为24个字节的PageHeader，记录该page相关的元数据信息。PageHeader中的pd_lower和pd_upper分别指向了页面空闲空间的首尾。</p><p>这里每一个tuple存储一条数据记录，从数据页底部开始向前依次存储。这些元组在页面中的位置存储在行指针line pointer中，每个行指针指向一个tuple。行指针从前向后依次存储，形成一个简单的数据。行指针中还存放了元组的状态和大小信息，扮演元组在页面中的索引的角色。行指针和tuple中间的部分为页面的空闲空间。</p><p>我们首先来看看PageHeader存储了什么元数据</p><h3 id="PageHeader">PageHeader</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PageXLogRecPtr  pd_lsn;</span><br><span class="line">    uint16          pd_checksum;</span><br><span class="line">    uint16          pd_flags;</span><br><span class="line">    LocationIndex   pd_lower;</span><br><span class="line">    LocationIndex   pd_upper;</span><br><span class="line">    LocationIndex   pd_special;</span><br><span class="line">    uint16          pd_pagesize_version;</span><br><span class="line">    TransactionId   pd_prune_xid;</span><br><span class="line">    ItemIdData      pd_linp[FLEXIBLE_ARRAY_MEMBER];</span><br><span class="line">&#125; PageHeaderData;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>pd_lsn</code>，记录了该页面最后一次更改的WAL log的lsn</p></li><li class="lvl-2"><p><code>pg_checksum</code>，页面校验和</p></li><li class="lvl-2"><p><code>pd_flags</code>，页面的标记为，包括以下标记</p><ul class="lvl-2"><li class="lvl-4"><code>PD_HAS_FREE_LINES</code>，页面中是否有unused line pointer. 这个unused的概念我们之后在看到line pointer时会介绍</li><li class="lvl-4"><code>PD_PAGE_FULL</code>，页面是否有足够的空闲空间给新的tuple</li><li class="lvl-4"><code>PD_ALL_VISIBLE</code>，页面中的所有元组是否对<strong>当前和之后</strong>的所有事务可见</li></ul></li><li class="lvl-2"><p><code>pd_lower</code>，指向空闲空间的起始位置</p></li><li class="lvl-2"><p><code>pd_upper</code>，指向空闲空间的结束位置</p></li><li class="lvl-2"><p><code>pd_special</code>，指向特殊空间的起始位置</p></li><li class="lvl-2"><p><code>pd_pagesize_version</code>，页面布局的版本号</p></li><li class="lvl-2"><p><code>pd_prune_xid</code>，用于页面元组清理时的标记位，记录了最旧的可清理的事务号。没有则为0</p></li><li class="lvl-2"><p><code>pg_linp</code>，页面行指针数组</p></li></ul><h3 id="页面的行指针结构">页面的行指针结构</h3><p>行指针是一个32位大小的索引结构，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ItemIdData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span>    lp_off:<span class="number">15</span>,</span><br><span class="line">                lp_flags:<span class="number">2</span>,</span><br><span class="line">                lp_len:<span class="number">15</span>;</span><br><span class="line">&#125; ItemIdData;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>lp_off</code>，记录了tuple在页面中的offset</p></li><li class="lvl-2"><p><code>lp_len</code>，记录了tuple的size</p></li><li class="lvl-2"><p><code>lp_flags</code>，是一个tuple状态的简单标记，方便在扫描元组时做一个初步筛选，有以下几个标记</p><ul class="lvl-2"><li class="lvl-4"><code>LP_UNUSED</code>，元组未使用，可以立刻被重用</li><li class="lvl-4"><code>LP_NORMAL</code>，元组状态正常</li><li class="lvl-4"><code>LP_REDIRECT</code>，元组被重定向了。用于PG的HOT链的头部和中间元组</li><li class="lvl-4"><code>LP_DEAD</code>，元组已死，但空间可能还没有回收</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开个新坑，简单写一写PostgreSQL中的元组管理。&lt;/p&gt;
&lt;p&gt;对于整个存储架构，各种PostgreSQL的相关书籍已经介绍的很详细了，这里也就不再重复造轮子了。下面我们主要基于面向对象（大雾），来看看元组这个对象，有哪些&lt;code&gt;成员变量&lt;/code&gt;，又有哪些&lt;</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/tags/PostgreSQL/"/>
    
    <category term="storage" scheme="https://spike1337.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>Linux · 工具 · devtodo · 简洁的终端todo工具</title>
    <link href="https://spike1337.github.io/2023/02/07/devtodo-manual/"/>
    <id>https://spike1337.github.io/2023/02/07/devtodo-manual/</id>
    <published>2023-02-07T02:23:30.000Z</published>
    <updated>2023-08-22T06:03:21.632Z</updated>
    
    <content type="html"><![CDATA[<p>devtodo是一款运行于终端的todo工具，简洁是它的最大优势。devtodo 目前已被许多 Linux 发行版的软件仓库收录，可以从软件仓库中安装它，也可以从它的项目主页<a href="https://github.com/alecthomas/devtodo">devtodo</a>下载最新版本编译安装。</p><h2 id="快速上手">快速上手</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">todo          <span class="comment"># 显示 todo list</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tda           <span class="comment"># 添加一项 todo，也可以用 todo -a 命令</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tde  &lt;index&gt;  <span class="comment"># 修改第 index 条 todo</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tdd  &lt;index&gt;  <span class="comment"># 标记第 index 条 todo 已经完成</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tdr  &lt;index&gt;  <span class="comment"># 删除第 index 条 todo</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">todo -A       <span class="comment"># 显示所有的 todo 条目，包括完成的以及未完成的</span></span></span><br></pre></td></tr></table></figure><h2 id="命令展示">命令展示</h2><ul class="lvl-0"><li class="lvl-2"><p>todo</p></li></ul><p>显示todo list。按优先级顺序排列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">todo</span></span><br><span class="line"></span><br><span class="line">1.test 1</span><br><span class="line">2.test 2</span><br><span class="line">3.test 3</span><br><span class="line">4.test 4</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>tda</p></li></ul><p>添加一项todo。设定todo内容，并设置todo优先级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tda</span></span><br><span class="line"></span><br><span class="line">Enter text for the item you are adding.</span><br><span class="line"><span class="meta prompt_">text&gt; </span><span class="language-bash"><span class="built_in">test</span> 1</span></span><br><span class="line">1. veryhigh   2. high   3. medium   4. low   5. verylow</span><br><span class="line">Enter a priority from those listed above.</span><br><span class="line"><span class="meta prompt_">priority&gt; </span><span class="language-bash">1</span></span><br><span class="line">Index of new item is 1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>tde k</p></li></ul><p>修改第 k 条 todo。可以重新编辑todo内容，并调整todo优先级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tde 1</span></span><br><span class="line"></span><br><span class="line">Modify the text of the item you are editing.</span><br><span class="line"><span class="meta prompt_">text&gt; </span><span class="language-bash"><span class="built_in">test</span> modify 1</span></span><br><span class="line">1. veryhigh   2. high   3. medium   4. low   5. verylow</span><br><span class="line">Enter a priority from those listed above.</span><br><span class="line"><span class="meta prompt_">priority&gt; </span><span class="language-bash">1</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>tdd k</p></li></ul><p>标记第 k 条 todo 已完成，可以设定完成的comment信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tdd 1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">comment&gt; </span><span class="language-bash"><span class="keyword">done</span></span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>tdr k</p></li></ul><p>删除第 k 条 todo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tdr k</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>todo -A</p></li></ul><p>查看所有的 todo notes，不包括被删除项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 2.test 2</span><br><span class="line">  3.test 3</span><br><span class="line">  4.test 4</span><br></pre></td></tr></table></figure><h2 id="进阶配置">进阶配置</h2><ol><li class="lvl-3"><p>全局todo nots记录</p></li></ol><p>默认的devtodo是在执行<code>tda</code>时，在执行目录下创建文件<code>.todo</code>来记录todo notes，执行其他操作时也是读取执行目录下的<code>.todo</code>文件。也就是每个执行目录有自己的todo list。如果我们想要一个全局的todo list，我们需要使用<code>-G</code>参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-G, --global            Use the database specified by the --global-database option. Defaults to ~/.todo_global.</span><br></pre></td></tr></table></figure><p><code>-G</code>参数使用 <code>~/.todo_global</code>作为存储todo notes的数据库，这样我们的todo就可以在全局范围内使用。作为懒狗我就直接将<code>-G</code>参数写入了alias</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alias todo=&quot;todo -G&quot;</span><br><span class="line">alias tda=&quot;tda -G&quot;</span><br><span class="line">alias tdd=&quot;tdd -G&quot;</span><br><span class="line">alias tde=&quot;tde -G&quot;</span><br><span class="line">alias tdr=&quot;tdr -G&quot;</span><br></pre></td></tr></table></figure><p>当然，如果不想使用默认的<code>~/.todo_global</code>文件作为全局数据库，也可以通过<code>--global-database</code>指定全局数据库的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--global-database ARG   Specify the database to use if the -G (--global) parameter is used.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一款运行于终端的todo管理工具</summary>
    
    
    
    <category term="Linux" scheme="https://spike1337.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://spike1337.github.io/tags/Linux/"/>
    
    <category term="tools" scheme="https://spike1337.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL · 源码解析 · MVCC机制</title>
    <link href="https://spike1337.github.io/2023/02/06/mvcc-source-code/"/>
    <id>https://spike1337.github.io/2023/02/06/mvcc-source-code/</id>
    <published>2023-02-06T06:36:45.000Z</published>
    <updated>2023-08-24T01:54:42.631Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL采用多版本并发控制（MVCC）来维护数据的一致性。检索数据时，每个事务看到的都只是一段时间之前的数据快照。MVCC并不能解决所有的并发控制情况，需要使用传统数据库的锁机制来保证事务的并发，因此在PostgreSQL里也有表和行级别的锁定机制。此外PostgreSQL还提供了会话锁机制，可以利用它一次对某个对象加锁保证对于多个事务都有效。</p><h2 id="事务隔离级别">事务隔离级别</h2><h3 id="标准事务隔离级别">标准事务隔离级别</h3><p>三个必须在并行的事务之间避免的现象：</p><ul class="lvl-0"><li class="lvl-4"><p>脏读：一个事务读取了另一个未提交的并行事务写的数据</p></li><li class="lvl-4"><p>不可重复读：一个事务对一个数据前后读取两次，发现该数据已经被另一个已提交的数据修改过</p></li><li class="lvl-4"><p>幻读：事务A读取某一范围内的数据行时，事务B在该范围内插入新行，当事务A再次读取该范围内的数据时无法查询到新增的数据</p></li></ul><p>四个事务隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>⭕</td><td>⭕</td><td>⭕</td></tr><tr><td>读已提交</td><td>❌</td><td>⭕</td><td>⭕</td></tr><tr><td>可重复读</td><td>❌</td><td>❌</td><td>⭕</td></tr><tr><td>可串行化</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><h3 id="PostgreSQL的隔离级别">PostgreSQL的隔离级别</h3><p>在PostgreSQL中，可以请求以上四种事务隔离级别的任意一种。但是在内部，只有两种独立的隔离级别：读已提交和可串行化。即选择读未提交的隔离级别，实际用的是读已提交。下面介绍PostgreSQL定义的两种隔离级别：</p><ul class="lvl-0"><li class="lvl-4"><p><strong>读已提交</strong>：缺省隔离级别。当一个事务运行在这个隔离级别时，一个<code>SELECT</code>查询只能看到查询开始之前提交的数据。如果两个事务在对同一元组进行更新，如果第一个事务回滚，则忽略其作用，第二个事务继续更新该元组；第二个事务则等待第一个事务提交或回滚。如果第一个事务提交，系统重新计算查询条件，如果符合则继续更新操作。</p></li><li class="lvl-4"><p><strong>可串行化</strong>：提供了最严格的事务隔离。模拟串行的事务执行。如果两个事务在对同一元组进行更新，第二个事务则等待第一个事务提交或回滚。如果第一个事务回滚，则忽略其作用，第二个事务继续更新该元组；如果第一个事务提交，那么可串行化事务回滚，从头开始进行整个事务。</p></li></ul><p>在PostgreSQL系统中，事务的隔离级别所涉及的最小对象是元组，所以对元组的操作需要实施访问控制。这个操作是通过锁操作以及MVCC相关的操作来实现的</p><h2 id="MVCC架构">MVCC架构</h2><p>在内部，PostgreSQL利用多版本并发控制（MVCC，MultiVersion Concurrency Control）来维护数据的一致性。即当检索数据时，每个事务看到的只是一段时间之前的事务快照，而不是数据的当前状态。这样对每个数据库会话进行事务隔离，就可以避免一个事务看到其他并发时的更新导致不一致的数据</p><h3 id="元组相关数据结构">元组相关数据结构</h3><p>在PostgreSQL系统中，更新数据并不是用新值覆盖旧值，而是在表中开辟一片空间来存放新的元组，新值与旧值同时存在于数据库中，只是通过设置一些参数让系统可以识别他们</p><p>元组的事务和命令控制信息存储在<code>HeapTupleFields</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleFields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TransactionId t_xmin;<span class="comment">// 创建此tuple的XID</span></span><br><span class="line">    TransactionId t_xmax;<span class="comment">// 删除此tuple的XID</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        CommandIdt_cid;<span class="comment">// 创建或删除tuple的CID，也可能二者都保存</span></span><br><span class="line">        TransactionId t_xvac;<span class="comment">// 清理操作的事务ID</span></span><br><span class="line">    &#125;t_field3;</span><br><span class="line">&#125; HeapTupleFields;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果一个事务确实创建并删除了同一个元组，则使用一个Combo Command ID 来保存Cmin和Cmax</p></li></ul><p>元组的相关控制信息存储在元组的头部<code>HeapTupleHeaderData</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">HeapTupleFields t_heap;</span><br><span class="line">DatumTupleFields t_datum;</span><br><span class="line">&#125;t_choice;</span><br><span class="line"></span><br><span class="line">ItemPointerData t_ctid;<span class="comment">// 本元组或更新元组的当前TID</span></span><br><span class="line">uint16t_infomask2;<span class="comment">// 属性、标记位数量标记位</span></span><br><span class="line">uint16t_infomask;<span class="comment">// 元组事务信息标记位</span></span><br><span class="line">uint8t_hoff;<span class="comment">// 头部长度</span></span><br><span class="line">bits8t_bits[FLEXIBLE_ARRAY_MEMBER];<span class="comment">// 标记作用的填充位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>其中，<code>t_ctid</code>当元组被保存在磁盘中时被初始化为自己的实际存储位置。如果元组被更新，<code>t_cid</code>指向更新后的新元组。如果要找到某个元组的最新版本，只需遍历由<code>t_ctid</code>构成的链表即可</p></li><li class="lvl-2"><p><code>t_infomask</code>字段表示当前元组的事务信息</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_HASNULL0x0001<span class="comment">// 空字段标记位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_HASVARWIDTH0x0002<span class="comment">// 变长字段标记位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_HASEXTERNAL0x0004<span class="comment">// 外部存储字段标记位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_HASOID_OLD0x0008<span class="comment">// 有OID字段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_KEYSHR_LOCK0x0010<span class="comment">// xmax是共享锁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_COMBOCID0x0020<span class="comment">// t_cid是combo cid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_EXCL_LOCK0x0040<span class="comment">// xmax是排他锁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_LOCK_ONLY0x0080<span class="comment">// xmax如果有效则只是一个锁</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// xmax is a shared locker</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_SHR_LOCK(HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_LOCK_MASK(HEAP_XMAX_SHR_LOCK | HEAP_XMAX_EXCL_LOCK | \</span></span><br><span class="line"><span class="meta"> HEAP_XMAX_KEYSHR_LOCK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMIN_COMMITTED0x0100<span class="comment">// t_xmin已提交</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMIN_INVALID0x0200<span class="comment">// t_xmin无效/中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMIN_FROZEN(HEAP_XMIN_COMMITTED|HEAP_XMIN_INVALID)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_COMMITTED0x0400<span class="comment">// t_xmax已提交</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_INVALID0x0800<span class="comment">// t_xmax无效/中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XMAX_IS_MULTI0x1000<span class="comment">// t_xmax是组合事务</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_UPDATED0x2000<span class="comment">// 更新后的新元组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MOVED_OFF0x4000<span class="comment">// 被之前版本的VACUUM FULL移到其他地方，用以兼容二进制升级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MOVED_IN0x8000<span class="comment">// 被之前版本的VACUUM FULL从其他地方移入，用以兼容二进制升级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MOVED (HEAP_MOVED_OFF | HEAP_MOVED_IN)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_XACT_MASK0xFFF0<span class="comment">// 可见性相关标记</span></span></span><br></pre></td></tr></table></figure><h3 id="MVCC">MVCC</h3><p>MVCC基本原理如图。有两个并发事务T1，T2，T1将元组C更新为C‘，但并没有提交。此时T2要对该元组进行查询，会通过C和C’的头部信息的Xmin和Xmax以及t_infomask来判断哪个为对当前事务的有效版本</p><p><img src="/uploads/pg_mvcc_base.png" alt="MVCC基本原理"></p><h4 id="MVCC与快照">MVCC与快照</h4><p>讨论MVCC的判断逻辑之前，我们需要先了解快照（snapshot）</p><p>快照（snapshot）记录了数据库当前某个时刻的活跃事务列表，通过快照确定某个元组的版本对于当前快照是否可见。快照定义在<code>SnapshotData</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SnapshotData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SnapshotType snapshot_type; <span class="comment">// 快照类型</span></span><br><span class="line"></span><br><span class="line">    TransactionId xmin;         <span class="comment">// 所有XID &lt; xmin对当前快照可见</span></span><br><span class="line">    TransactionId xmax;         <span class="comment">// 所有XID &gt;= xmax对当前快照可见</span></span><br><span class="line"></span><br><span class="line">    TransactionId *xip;         <span class="comment">// 当前活跃事务的链表</span></span><br><span class="line">    uint32      xcnt;           <span class="comment">// 当前活跃事务链表长度</span></span><br><span class="line"></span><br><span class="line">    TransactionId *subxip;      <span class="comment">// 当前活跃子事务链表</span></span><br><span class="line">    int32       subxcnt;        <span class="comment">// 当前活跃子事务链表的长度</span></span><br><span class="line">    <span class="type">bool</span>        suboverflowed;  <span class="comment">// 活跃子事务数组是否移除</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span>        takenDuringRecovery;    <span class="comment">// 是否是在Recovery中的快照</span></span><br><span class="line">    <span class="type">bool</span>        copied;         <span class="comment">// 静态快照则为false</span></span><br><span class="line"></span><br><span class="line">    CommandId   curcid;         <span class="comment">// 所有CID &lt; curcid是可见的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HeapTupleSatisfiesDirty中的额外返回值，并没有在MVCC快照中使用</span></span><br><span class="line">    uint32      speculativeToken;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由快照管理器使用的信息</span></span><br><span class="line">    uint32      active_count;   <span class="comment">// 在活跃快照链表里的引用计数</span></span><br><span class="line">    uint32      regd_count;     <span class="comment">// 在已注册的快照链表里的引用计数</span></span><br><span class="line">    pairingheap_node ph_node;   <span class="comment">// 已注册的快照链表</span></span><br><span class="line"></span><br><span class="line">    TimestampTz whenTaken;      <span class="comment">// 记录快照的时间戳</span></span><br><span class="line">    XLogRecPtr  lsn;            <span class="comment">// 记录快照时在WAL中的位置</span></span><br><span class="line">&#125; SnapshotData;</span><br></pre></td></tr></table></figure><p>在PostgreSQL中有默认的7种形式快照（15.1），分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">SnapshotType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 元组对于给定的MVCC快照有效</span></span><br><span class="line">    SNAPSHOT_MVCC = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组对于自身有效</span></span><br><span class="line">    SNAPSHOT_SELF,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任何元组都是可见的</span></span><br><span class="line">    SNAPSHOT_ANY,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组作为TOAST行 有效</span></span><br><span class="line">    SNAPSHOT_TOAST,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面三个不太好解释，直接贴原文</span></span><br><span class="line">    <span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * A tuple is visible iff the tuple is valid including effects of open</span></span><br><span class="line"><span class="comment">     * transactions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here, we consider the effects of:</span></span><br><span class="line"><span class="comment">     * - all committed and in-progress transactions (as of the current instant)</span></span><br><span class="line"><span class="comment">     * - previous commands of this transaction</span></span><br><span class="line"><span class="comment">     * - changes made by the current command</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is essentially like SNAPSHOT_SELF as far as effects of the current</span></span><br><span class="line"><span class="comment">     * transaction and committed/aborted xacts are concerned.  However, it</span></span><br><span class="line"><span class="comment">     * also includes the effects of other xacts still in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A special hack is that when a snapshot of this type is used to</span></span><br><span class="line"><span class="comment">     * determine tuple visibility, the passed-in snapshot struct is used as an</span></span><br><span class="line"><span class="comment">     * output argument to return the xids of concurrent xacts that affected</span></span><br><span class="line"><span class="comment">     * the tuple.  snapshot-&gt;xmin is set to the tuple&#x27;s xmin if that is</span></span><br><span class="line"><span class="comment">     * another transaction that&#x27;s still in progress; or to</span></span><br><span class="line"><span class="comment">     * InvalidTransactionId if the tuple&#x27;s xmin is committed good, committed</span></span><br><span class="line"><span class="comment">     * dead, or my own xact.  Similarly for snapshot-&gt;xmax and the tuple&#x27;s</span></span><br><span class="line"><span class="comment">     * xmax.  If the tuple was inserted speculatively, meaning that the</span></span><br><span class="line"><span class="comment">     * inserter might still back down on the insertion without aborting the</span></span><br><span class="line"><span class="comment">     * whole transaction, the associated token is also returned in</span></span><br><span class="line"><span class="comment">     * snapshot-&gt;speculativeToken.  See also InitDirtySnapshot().</span></span><br><span class="line"><span class="comment">     * -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SNAPSHOT_DIRTY,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A tuple is visible iff it follows the rules of SNAPSHOT_MVCC, but</span></span><br><span class="line"><span class="comment">     * supports being called in timetravel context (for decoding catalog</span></span><br><span class="line"><span class="comment">     * contents in the context of logical decoding).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 元组对MVCC快照有效，且支持逻辑复制</span></span><br><span class="line">    SNAPSHOT_HISTORIC_MVCC,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A tuple is visible iff the tuple might be visible to some transaction;</span></span><br><span class="line"><span class="comment">     * false if it&#x27;s surely dead to everyone, i.e., vacuumable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For visibility checks snapshot-&gt;min must have been set up with the xmin</span></span><br><span class="line"><span class="comment">     * horizon to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 元组对某些事务可见，如果对所有事务都是dead tuple，也就是vacuumable，则返回false</span></span><br><span class="line">    SNAPSHOT_NON_VACUUMABLE</span><br><span class="line">&#125; SnapshotType;</span><br></pre></td></tr></table></figure><h3 id="MVCC机制的实现">MVCC机制的实现</h3><p>以函数<code>HeapTupleSatisfiesSelf</code>为例，下面介绍MVCC机制的具体实现。如果返回值为True，则该元组是可见的。判断时会考虑三个方面的因素：所有已提交的事务，当前事务前的所有命令以及当前命令前的所有操作。执行过程如下：</p><ul class="lvl-0"><li class="lvl-2"><p>检查Xmin是否为已提交，如果元组的Xmin还未提交</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xmin未提交</span></span><br><span class="line"><span class="keyword">if</span> (!HeapTupleHeaderXminCommitted(tuple))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Xmin无效，元组不可见</span></span><br><span class="line">    <span class="keyword">if</span> (HeapTupleHeaderXminInvalid(tuple))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容二进制升级</span></span><br><span class="line">    <span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_MOVED_OFF)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 兼容二进制升级</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_MOVED_IN)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Xmin为当前事务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Xmax无效，则XID无效，可见</span></span><br><span class="line">        <span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_INVALID)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Xmax被锁定，即元组被锁定，可见</span></span><br><span class="line">        <span class="keyword">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Xmax是组合事务</span></span><br><span class="line">        <span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI)</span><br><span class="line">        &#123;</span><br><span class="line">            xmax = HeapTupleGetUpdateXid(tuple);</span><br><span class="line">            <span class="comment">// 更新子事务必须已回滚，因为前提是Xmin未提交</span></span><br><span class="line">            <span class="keyword">if</span> (!TransactionIdIsCurrentTransactionId(xmax))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Xmax为当前事务</span></span><br><span class="line">        <span class="keyword">if</span> (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 删除子事务必须已终止</span></span><br><span class="line">            SetHintBits(tuple, buffer, HEAP_XMAX_INVALID,</span><br><span class="line">                        InvalidTransactionId);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Xmin正在某个后端进程中运行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Xmin已经被提交</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))</span><br><span class="line">        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,</span><br><span class="line">                    HeapTupleHeaderGetRawXmin(tuple));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 否则一定是中止或崩溃</span></span><br><span class="line">        SetHintBits(tuple, buffer, HEAP_XMIN_INVALID,</span><br><span class="line">                    InvalidTransactionId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Xmin已提交。如果Xmax无效或中断，元组可见</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_INVALID)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Xmin已提交，Xmax已提交</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_COMMITTED)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果Xmax被锁定，可见</span></span><br><span class="line">    <span class="keyword">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Xmin已提交，Xmax为组合事务</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI)</span><br><span class="line">&#123;</span><br><span class="line">    TransactionId xmax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Xmax被锁定，可见</span></span><br><span class="line">    <span class="keyword">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    xmax = HeapTupleGetUpdateXid(tuple);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Xmax是当前事务</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionIdIsCurrentTransactionId(xmax))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Xmax正在被某个后端进程执行</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionIdIsInProgress(xmax))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Xmax已经被提交</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionIdDidCommit(xmax))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 否则事务被中断或崩溃</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Xmin已提交，Xmax不是组合事务</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xmax是当前事务</span></span><br><span class="line"><span class="keyword">if</span> (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Xmax正在被某个后端进程执行</span></span><br><span class="line"><span class="keyword">if</span> (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Xmax已经被提交</span></span><br><span class="line"><span class="keyword">if</span> (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// it must have aborted or crashed</span></span><br><span class="line">    SetHintBits(tuple, buffer, HEAP_XMAX_INVALID,</span><br><span class="line">                InvalidTransactionId);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Xmax被锁定</span></span><br><span class="line"><span class="keyword">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))</span><br><span class="line">&#123;</span><br><span class="line">    SetHintBits(tuple, buffer, HEAP_XMAX_INVALID,</span><br><span class="line">                InvalidTransactionId);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SNAPSHOT_SELF</code>所对应的MVCC判断机制如上，其他snapshot类型对应的判断逻辑类似，就不再详细介绍了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PostgreSQL采用多版本并发控制（MVCC）来维护数据的一致性。检索数据时，每个事务看到的都只是一段时间之前的数据快照。MVCC并不能解决所有的并发控制情况，需要使用传统数据库的锁机制来保证事务的并发，因此在PostgreSQL里也有表和行级别的锁定机制。此外Post</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/tags/PostgreSQL/"/>
    
    <category term="transaction" scheme="https://spike1337.github.io/tags/transaction/"/>
    
    <category term="MVCC" scheme="https://spike1337.github.io/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL · 源码解析 · WAL日志</title>
    <link href="https://spike1337.github.io/2023/02/03/pg-wal-source-code/"/>
    <id>https://spike1337.github.io/2023/02/03/pg-wal-source-code/</id>
    <published>2023-02-03T05:44:58.000Z</published>
    <updated>2023-08-24T01:54:50.544Z</updated>
    
    <content type="html"><![CDATA[<p>Postgresql 使用 wal 日志保存每一次的数据修改，这样保证了数据库即使意外宕机，也能利用它准确的恢复数据。wal 日志也叫做 xlog，在 9.4 版本之后作了重大更新，本篇只讲解最新版的格式。wal 日志被用于多个方面，比如修改数据，修改索引等，每种用途的格式都不相同，但是构建方式是相同的。</p><h2 id="WAL日志文件">WAL日志文件</h2><h3 id="WAL段文件">WAL段文件</h3><p>WAL日志文件存放在sd_wal目录下，每个文件大小默认为16M：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000B6</span><br><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000B7</span><br><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000B8</span><br><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000B9</span><br><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000BA</span><br><span class="line">-rw-------  1 zhangze  zhangze  16777216 Oct  8 10:57 0000000100000000000000BB</span><br><span class="line">drwx------  2 zhangze  zhangze        68 Oct  8 10:53 archive_status</span><br></pre></td></tr></table></figure><p>文件名由16进制的24个字符组成，每8个字符为一组，每组意义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000001 00000000 000000B6</span><br><span class="line"> 时间线    LogID    LogSeg</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>时间线</strong>：时间线ID，取值范围为 0x00000000 -&gt; 0xFFFFFFFF。数据库建好后的第一个WAL日志文件的时间线ID从1开始</p></li><li class="lvl-2"><p><strong>LogID</strong>：逻辑文件ID，取值范围为 0x00000000 -&gt; 0xFFFFFFFF</p></li><li class="lvl-2"><p><strong>LogSeg</strong>：物理文件ID，取值范围为 0x00000000 -&gt; 0x000000FF。数据库建好后的第一个WAL日志文件的LogSeg从1开始，达到最大值（0xFF）后从0开始。</p></li></ul><p><strong>LSN</strong>即日志序列号，表示XLog记录在事务日志文件中的偏移，为uint64值。LSN由三部分组成，分别是逻辑文件ID，物理文件ID和文件内偏移量。LSN打印出来是两个8位的十六进制数，如16/B374D848。由专门的类型<code>pg_lsn</code>来存放LSN数据</p><p>PG WAL文件名字的命名方法是在XLogFileName宏里定义的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XLogSegmentsPerXLogId(wal_segsz_bytes)  \</span></span><br><span class="line"><span class="meta">    (UINT64CONST(0x100000000) / (wal_segsz_bytes))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XLogFileName(fname, tli, logSegNo, wal_segsz_bytes) \</span></span><br><span class="line"><span class="meta">    snprintf(fname, MAXFNAMELEN, <span class="string">&quot;%08X%08X%08X&quot;</span>, tli,       \</span></span><br><span class="line"><span class="meta">             (uint32) ((logSegNo) / XLogSegmentsPerXLogId(wal_segsz_bytes)), \</span></span><br><span class="line"><span class="meta">             (uint32) ((logSegNo) % XLogSegmentsPerXLogId(wal_segsz_bytes)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XLogFileNameById(fname, tli, log, seg)  \</span></span><br><span class="line"><span class="meta">    snprintf(fname, MAXFNAMELEN, <span class="string">&quot;%08X%08X%08X&quot;</span>, tli, log, seg)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IsXLogFileName(fname) \</span></span><br><span class="line"><span class="meta">    (strlen(fname) == XLOG_FNAME_LEN &amp;&amp; \</span></span><br><span class="line"><span class="meta">     strspn(fname, <span class="string">&quot;0123456789ABCDEF&quot;</span>) == XLOG_FNAME_LEN)</span></span><br></pre></td></tr></table></figure><h3 id="WAL文件内部结构">WAL文件内部结构</h3><p>每个WAL段文件由多个8kb大小的page组成，每个Page中存放着PageHeader信息，以及多条WAL Record</p><h4 id="Page结构">Page结构</h4><p>每个page的组织方式如下图：</p><p><img src="/uploads/WALPage.png" alt="WAL的page结构"></p><ul class="lvl-0"><li class="lvl-2"><p><strong>PageHeader</strong>：在wal page的组成中有两种pageheader结构，<code>XLogPageHeaderData</code>和<code>XLogLongPageHeaderData</code>。每个WAL段的第一个Page的Header应为LongHeader</p></li><li class="lvl-2"><p><strong>Remain data</strong>：存储着上一个page中最后一个Record没有存完的数据，大小为<code>xlp_rem_len</code>，对应page的不完整Record</p></li><li class="lvl-2"><p><strong>Record</strong>：存储具体的WAL Record</p></li><li class="lvl-2"><p><strong>无数据区域</strong>：一个WAL Record的头部信息不允许跨页，如果剩余空间不够存储头部信息，则舍弃这部分空间</p></li></ul><h4 id="Record结构">Record结构</h4><p>每个WAL Record的结构如下图，绿色部分为数据描述结构，黄色部分是实际保存的数据</p><p><img src="/uploads/wal_write.png" alt="WAL_Record"></p><ul class="lvl-0"><li class="lvl-2"><p><strong>XLogRecord</strong>：一个WAL记录的入口，解析WAL时，从这个结构体入手</p></li><li class="lvl-2"><p><strong>Block</strong>：第一个虚线框称为一个BLOCK，用以描述Buffer相关的数据结构。通过<code>XLogRegisterBuffer()</code>函数注册到wal记录中</p><ul class="lvl-2"><li class="lvl-6"><strong>XLogRecordBlockHeader</strong>：一个BLOCK的头部信息</li><li class="lvl-6"><strong>XLogRecordBlockImageHeader</strong>：如果该WAL是fpw记录，该结构存放fpw相关信息<ul class="lvl-4"><li class="lvl-10">fpw：Full_page_write，具体见<a href="#%E6%95%B4%E9%A1%B5%E5%86%99%E5%85%A5full_write_page">整页写入</a></li></ul></li><li class="lvl-6"><strong>XLogRecordBlockCompressHeader</strong>：记录hole的大小<ul class="lvl-4"><li class="lvl-10">hole：数据文件的page中，可能会有一块空白区域，即pointer和tuple之间的区域，称为hole</li></ul></li><li class="lvl-6"><strong>RelFilenode</strong>：此结构记录了此block所属的关系</li><li class="lvl-6"><strong>BlockNumber</strong>：此block记录的page的块号</li></ul></li><li class="lvl-2"><p><strong>XLogRecordDataHeader(Long/short)</strong>：当main data的大小大于255时，使用Long Header</p></li><li class="lvl-2"><p><strong>buffer data</strong>：第二个虚线框部分，包括page data和tuple data</p><ul class="lvl-2"><li class="lvl-6"><strong>page data</strong>：由<code>XLogRegisterBuffer()</code>函数注册到wal记录，存放buffer page信息</li><li class="lvl-6"><strong>tuple data</strong>：由<code>XLogRegisterBufData()</code>函数注册到wal记录，存储了实际的buff数据和变更数据。</li></ul></li><li class="lvl-2"><p><strong>main data</strong>：保存非buffer性的数据，由<code>XLogRegisterData()</code>函数到WAL记录，例如特殊结构体，旧元组或key</p></li></ul><h2 id="WAL日志写入实现">WAL日志写入实现</h2><p>当数据库数据发生变更时：</p><ul class="lvl-0"><li class="lvl-2"><p>change发生时：先要将变更后内容计入wal buffer中，再将变更后的数据写入data buffer；</p></li><li class="lvl-2"><p>commit发生时：wal buffer中数据刷新到磁盘；</p></li><li class="lvl-2"><p>checkpoint发生时：将所有data buffer刷新的磁盘。</p></li></ul><p>WAL日志机制就是先将变更内容存放到wal buffer，commit后将wal buffer刷入磁盘的过程。过程中主要的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XLogBeginInsert();        <span class="comment">// 表示开始构建 xlog</span></span><br><span class="line">XLogRegisterData();       <span class="comment">// 将WAL记录的特殊结构体数据注册到WAL，比如heap_insert中的xl_heap_insert结构体</span></span><br><span class="line">XLogRegisterBuffer();     <span class="comment">// 将涉及到的buf注册到wal记录，比如heap_insert中page页赋予regbuf-&gt;page</span></span><br><span class="line">XLogRegisterBufData();    <span class="comment">// 将元组内容注册到WAL记录，比如insert语句的元组数据等</span></span><br><span class="line">XLogSetRecordFlags();</span><br><span class="line">XLogInsert();</span><br><span class="line">    XLogRecordAssemble();</span><br><span class="line">    XLogInsertRecord();   <span class="comment">// 根据当前的数据库状态，把上述函数注册的数据进行筛选组装，最终形成完整的wal记录并写入到walbuff</span></span><br><span class="line">PageSetLSN</span><br></pre></td></tr></table></figure><p><img src="/uploads/wal_process.png" alt="WAL实现过程"></p><h3 id="整页写入-Full-Write-Page">整页写入(Full_Write_Page)</h3><p>如果数据库系统在写入脏页的过程中出现故障，会导致磁盘上的页面数据损坏，而XLOG是无法在损坏的页面上重放的，需要整页写入来恢复。</p><p>如果启用整页写入，PostgreSQL会在每个检查点后，每个页面第一次变更发生前，将整个页面以及Header信息作为一条XLog写入，这个功能默认开启。在数据库恢复过程中，如果检查到一条XLog是一个用来整页写入的备份区块，会使用另一条重放规则：XLog会直接覆盖当前页面，无视页面和XLog记录中的LSN，然后将页面的LSN更新为XLog记录的LSN</p><h3 id="具体数据结构">具体数据结构</h3><h4 id="XLog-Page">XLog Page</h4><h5 id="XLogPageHeaderData">XLogPageHeaderData</h5><p>XLog日志分为很多逻辑段文件，每个段文件分成许多个页面，每个页面的大小为一个块的大小。每个日志页面都有一个头部信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogPageHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint16xlp_magic;<span class="comment">// 校验位，检验WAL的版本信息</span></span><br><span class="line">    uint16xlp_info;<span class="comment">// 标记位</span></span><br><span class="line">    TimeLineIDxlp_tli;<span class="comment">// 页面第一条记录的时间序列</span></span><br><span class="line">    XLogRecPtrxlp_pageaddr;<span class="comment">// XLog页面的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前页面没有足够空间用于记录时，继续在下一页记录</span></span><br><span class="line">    <span class="comment">// 记录了前一页的剩余字节数，包括备份块数据，即该记录在本页继续存储占用的空间大小</span></span><br><span class="line">    uint32xlp_rem_len;</span><br><span class="line">&#125; XLogPageHeaderData;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>其中，标记位<code>xlp_info</code>只使用最低两位，0表明该页的第一个XLog记录接着上一页的最后一个XLog记录，1表示该页是该XLog文件的首页</p></li></ul><h5 id="XLogLongPageHeaderData">XLogLongPageHeaderData</h5><p>如果页面是该日志文件的首页，那么在原头部信息的基础上会使用一个长的头部信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogLongPageHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XLogPageHeaderData <span class="built_in">std</span>;<span class="comment">// 标准的头部信息，即 XLogPageHeaderData</span></span><br><span class="line">    uint64xlp_sysid;<span class="comment">// pg_control中的系统标识符</span></span><br><span class="line">    uint32xlp_seg_size;<span class="comment">// 校验位，段的大小</span></span><br><span class="line">    uint32xlp_XLog_blcksz;<span class="comment">// 校验位，块的大小</span></span><br><span class="line">&#125; XLogLongPageHeaderData;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>对于长的XLog日志记录，允许将没有足够空间存储的数据存储到下一个页面，但不允许Record头部信息被分开存储到两个不同页面。如果剩余空间已经不足以存储一个头部信息，那么剩余空间将被舍弃，将这个XLog记录存储到新的下一个页面中</p></li></ul><h4 id="XLog-Record">XLog Record</h4><h5 id="XLogRecord">XLogRecord</h5><p>结构<code>XLogRecord</code>记录了XLog的相关控制信息，一个XLog记录最多可以附3个备份块， 每个块对应一个磁盘大小的数据，长度为8kb</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecord</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint32xl_tot_len;<span class="comment">// 整条记录的长度</span></span><br><span class="line">TransactionId xl_xid;<span class="comment">// 事务ID</span></span><br><span class="line">XLogRecPtrxl_prev;<span class="comment">// 指向日志中的前一个记录</span></span><br><span class="line">uint8xl_info;<span class="comment">// 信息标记位</span></span><br><span class="line">RmgrIdxl_rmid;<span class="comment">// 资源管理器</span></span><br><span class="line"></span><br><span class="line">pg_crc32cxl_crc;<span class="comment">// 本记录的CRC校验码</span></span><br><span class="line">&#125; XLogRecord;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>其中，资源管理器号主要用于日志系统中，数据库系统需要将记录的日志数据分类，为它们分配对应的资源管理器号。读取日志记录时，结合资源管理器号和信息标志位，能够直到数据库对源数据做的是哪种操作，从而迅速正确的调用对应的函数。共有16种资源</p></li><li class="lvl-2"><p>信息标志位的高4位由资源管理器使用，标识该日志是哪种类型的日志。低4位表示对应的块是否需要备份</p></li></ul><h5 id="XLogRecordBlockHeader">XLogRecordBlockHeader</h5><p>存放block的相关信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordBlockHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint8       id;             <span class="comment">// 块引用ID</span></span><br><span class="line">    uint8       fork_flags;     <span class="comment">// 在关系中使用的fork和flags</span></span><br><span class="line">    uint16      data_length;    <span class="comment">// payload字节大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了 BKPBLOCK_HAS_IMAGE,后续为XLogRecordBlockImageHeader结构体，否则为RelFileNode</span></span><br><span class="line">    <span class="comment">//之后为BlockNumber</span></span><br><span class="line">&#125; XLogRecordBlockHeader;</span><br></pre></td></tr></table></figure><h5 id="XLogRecordBlockImageHeader">XLogRecordBlockImageHeader</h5><p>存放整页写入的相关信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordBlockImageHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint16length;<span class="comment">// page大小</span></span><br><span class="line">uint16hole_offset;<span class="comment">// hole之前的长度</span></span><br><span class="line">uint8bimg_info;<span class="comment">// 标记位，是否压缩</span></span><br><span class="line">&#125; XLogRecordBlockImageHeader;</span><br></pre></td></tr></table></figure><h5 id="XLogRecordBlockCompressHeader">XLogRecordBlockCompressHeader</h5><p>存放page中的hole大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordBlockCompressHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint16hole_length;<span class="comment">// hole大小</span></span><br><span class="line">&#125; XLogRecordBlockCompressHeader;</span><br></pre></td></tr></table></figure><h4 id="XLog-Data">XLog Data</h4><h5 id="XLogRecordDataHeader">XLogRecordDataHeader</h5><p>WAL Record的数据部分的header信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordDataHeaderShort</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint8       id;</span><br><span class="line">    uint8       data_length;</span><br><span class="line">&#125;XLogRecordDataHeaderShort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordDataHeaderLong</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint8       id;</span><br><span class="line">&#125;XLogRecordDataHeaderLong;</span><br></pre></td></tr></table></figure><h5 id="XLogRecData">XLogRecData</h5><p>XLog日志记录中的数据信息存储在结构<code>XLogRecData</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XLogRecData</span> *<span class="title">next</span>;</span><span class="comment">// 下一个节点</span></span><br><span class="line"><span class="type">char</span>    *data;<span class="comment">// 数据</span></span><br><span class="line">uint32len;<span class="comment">// 数据长度</span></span><br><span class="line">&#125; XLogRecData;</span><br></pre></td></tr></table></figure><h4 id="XLog控制结构">XLog控制结构</h4><h5 id="XLogCtlData">XLogCtlData</h5><p>在共享内存中用结构<code>XLogCtlData</code>保存XLog信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogCtlData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    XLogCtlInsert Insert;<span class="comment">// 插入一条日志后，最新的相关信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下受info_lck保护</span></span><br><span class="line">    XLogwrtRqst LogwrtRqst;<span class="comment">// 将日志写入和同步的位置</span></span><br><span class="line">    XLogRecPtrRedoRecPtr;<span class="comment">// 最近的 Insert-&gt;RedoRecPtr 副本</span></span><br><span class="line">    FullTransactionId ckptFullXid;<span class="comment">// 最新检查点的nextXID</span></span><br><span class="line">    XLogRecPtrasyncXactLSN;<span class="comment">// 最新异步提交/中断的LSN</span></span><br><span class="line">    XLogRecPtrreplicationSlotMinLSN;<span class="comment">// 所有缓冲区所需的最老的LSN</span></span><br><span class="line"></span><br><span class="line">    XLogSegNolastRemovedSegNo;<span class="comment">// 最后的删除/回收的XLog段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于不需要记录日志的关系的假的LSN</span></span><br><span class="line">    XLogRecPtrunloggedLSN;</span><br><span class="line">    <span class="type">slock_t</span>ulsn_lck;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换后最新的XLog的时间和LSN，受XLogWriteLock保护</span></span><br><span class="line">    <span class="type">pg_time_t</span>lastSegSwitchTime;</span><br><span class="line">    XLogRecPtrlastSegSwitchLSN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经写入和同步的位置，受info_lck或XLogWriteLock保护</span></span><br><span class="line">    XLogwrtResult LogwrtResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存中的最后初始化页面，最后一个字节位置+1</span></span><br><span class="line">    XLogRecPtrInitializedUpTo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些值在启动后不会修改，尽管指向的页面和xlblocks通常会改变</span></span><br><span class="line">    <span class="comment">// xlblocks受 XLogBufMappingLock 保护</span></span><br><span class="line">    <span class="type">char</span>   *pages;<span class="comment">// 未写入XLog页面的缓冲区</span></span><br><span class="line">    XLogRecPtr *xlblocks;<span class="comment">// 缓冲区内容对应的XLog文件的内部指针</span></span><br><span class="line">    <span class="type">int</span>XLogCacheBlck;<span class="comment">// XLog最大缓冲区的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThisTimeLineID 的共享副本，在完成恢复后不要修改</span></span><br><span class="line">    TimeLineIDThisTimeLineID;</span><br><span class="line">    TimeLineIDPrevTimeLineID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记我们是否处于崩溃或恢复状态，受info_lock保护</span></span><br><span class="line">    RecoveryState SharedRecoveryState;</span><br><span class="line">    <span class="type">bool</span>SharedHotStandbyActive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示XLog写入是否处于节能模式，受info_lock保护</span></span><br><span class="line">    <span class="type">bool</span>XLogWriterSleeping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待唤醒，如果出现出发文件，则唤醒启动进程以继续执行XLog重放</span></span><br><span class="line">    LatchrecoveryWakeupLatch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在恢复期间保留最后检查点记录的副本，受info_lck保护</span></span><br><span class="line">    XLogRecPtrlastCheckPointRecPtr;</span><br><span class="line">    XLogRecPtrlastCheckPointEndPtr;</span><br><span class="line">    CheckPointlastCheckPoint;</span><br><span class="line"></span><br><span class="line">    XLogRecPtrlastReplayedEndRecPtr;<span class="comment">// 指向成功重放的最后一条记录的结尾+1</span></span><br><span class="line">    TimeLineIDlastReplayedTLI;</span><br><span class="line">    XLogRecPtrreplayEndRecPtr;<span class="comment">// 如果正处于redo函数回放记录期间，则指向正在恢复记录的结尾+1</span></span><br><span class="line">    <span class="comment">// 否则等于lastReplayedEndRecPtr</span></span><br><span class="line">    TimeLineIDreplayEndTLI;</span><br><span class="line">    TimestampTz recoveryLastXTime;<span class="comment">// 重放（正在重放）的最后一个COMMIT/ABORT记录的时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始重放当前XLog数据块的时间戳</span></span><br><span class="line">    TimestampTz currentChunkStartTime;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span>recoveryPause;<span class="comment">// 是否暂停恢复</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向最后重放的XLog_FPW_CHANGE记录的起始点</span></span><br><span class="line">    <span class="comment">// 用于禁用full_page_writes</span></span><br><span class="line">    XLogRecPtrlastFpwDisableRecPtr;</span><br><span class="line"></span><br><span class="line">    <span class="type">slock_t</span>info_lck;<span class="comment">// 共享锁</span></span><br><span class="line">&#125; XLogCtlData;</span><br></pre></td></tr></table></figure><h5 id="Register-buffer">Register_buffer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">bool</span>in_use;<span class="comment">// is this slot in use?</span></span><br><span class="line">uint8flags;<span class="comment">// REGBUF_* flags</span></span><br><span class="line">RelFileNode rnode;<span class="comment">// 指定所属表的存储目录</span></span><br><span class="line">ForkNumberforkno;         <span class="comment">// 哪种文件类型</span></span><br><span class="line">BlockNumber block;          <span class="comment">// 块编号</span></span><br><span class="line">Pagepage;<span class="comment">// 对应的原始数据页</span></span><br><span class="line"></span><br><span class="line">uint32rdata_len;<span class="comment">// 私有数据链表的长度总和</span></span><br><span class="line">XLogRecData *rdata_head;<span class="comment">// 私有数据链表头部节点</span></span><br><span class="line">XLogRecData *rdata_tail;<span class="comment">// 私有数据链表尾部节点</span></span><br><span class="line"></span><br><span class="line">XLogRecData bkp_rdatas[<span class="number">2</span>];<span class="comment">// 存储着压缩后或忽略空闲数据的数据，如果有空闲位置且没有压缩，那么数据会被分成两个部分，存储在两个数组元素里</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>compressed_page[PGLZ_MAX_BLCKSZ]; <span class="comment">// 如果开启了压缩，那么存储着压缩后的数据</span></span><br><span class="line">&#125; registered_buffer;</span><br></pre></td></tr></table></figure><h4 id="重要全局变量">重要全局变量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> XLogRecData *mainrdata_head;</span><br><span class="line"><span class="type">static</span> XLogRecData *mainrdata_last = (XLogRecData *) &amp;mainrdata_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用XLogRegisterBuffer注册的数据存储到registered_buffers数组里*/</span></span><br><span class="line"><span class="type">static</span> registered_buffer *registered_buffers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用XLogRegisterBufData注册的数据存储到rdatas数组里，并链接为链表，使用registered_buffer结构里的rdata_head和</span></span><br><span class="line"><span class="comment"> * rdata_tail作为链表的首尾。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用XLogRegisterData注册的数据存储到rdatas数组里，并使用mainrdata_head和mainrdata_lastata注册的数据存储到rdatas数组里，</span></span><br><span class="line"><span class="comment"> * 并链接为链表，使用registered_buffer结构里的rdata_head和rdata_tail作为链表的首尾。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> XLogRecData *rdatas;</span><br></pre></td></tr></table></figure><h3 id="具体函数代码">具体函数代码</h3><h4 id="XLogBeginInsert">XLogBeginInsert</h4><p>函数主要作用是检验调用环境是否正确，判断当前是否可以执行xlog插入，并设置开始构造WAL记录的标记，标志wal插入开始。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Assert(max_registered_block_id == <span class="number">0</span>);</span><br><span class="line">Assert(mainrdata_last == (XLogRecData *) &amp;mainrdata_head);</span><br><span class="line">Assert(mainrdata_len == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!XLogInsertAllowed())</span><br><span class="line">    elog(ERROR, <span class="string">&quot;cannot make new WAL entries during recovery&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (begininsert_called)</span><br><span class="line">    elog(ERROR, <span class="string">&quot;XLogBeginInsert was already called&quot;</span>);</span><br><span class="line"></span><br><span class="line">begininsert_called = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="XLogRegisterData">XLogRegisterData</h4><ol><li class="lvl-3"><p>将本条wal记录的特殊结构体数据注册到wal记录，比如XLOG_HEAP_INSERT子类型的xl_heap_insert结构体。</p></li><li class="lvl-3"><p>将一些旧元组数据注册到wal记录，比如执行update语句的旧元组数据、delete语句的旧元组数据。</p></li></ol><p><img src="/uploads/xlog_register_data.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否已经开始构造WAL</span></span><br><span class="line">Assert(begininsert_called);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查数据量是否超过限制值</span></span><br><span class="line"><span class="keyword">if</span> (num_rdatas &gt;= max_rdatas)</span><br><span class="line">    elog(ERROR, <span class="string">&quot;too much WAL data&quot;</span>);</span><br><span class="line">rdata = &amp;rdatas[num_rdatas++];</span><br><span class="line"></span><br><span class="line">rdata-&gt;data = data;</span><br><span class="line">rdata-&gt;len = len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 mainrdata_last 指针跟踪链条的结束点,在这里不需要清除next变量</span></span><br><span class="line">mainrdata_last-&gt;next = rdata;</span><br><span class="line">mainrdata_last = rdata;</span><br><span class="line"></span><br><span class="line">mainrdata_len += len;</span><br></pre></td></tr></table></figure><h4 id="XLogRegisterBuffer">XLogRegisterBuffer</h4><p>将涉及到的buff注册到wal记录，比如insert语句的目标buff、update语句的目标buff和源buff</p><p><img src="/uploads/xlog_register_buf.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到registered_buffer数组中第一个空的的位置</span></span><br><span class="line"><span class="keyword">if</span> (block_id &gt;= max_registered_block_id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (block_id &gt;= max_registered_buffers)</span><br><span class="line">        elog(ERROR, <span class="string">&quot;too many registered buffers&quot;</span>);</span><br><span class="line">    max_registered_block_id = block_id + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将这个buffer的数据填充</span></span><br><span class="line">regbuf = &amp;registered_buffers[block_id];</span><br><span class="line"></span><br><span class="line">BufferGetTag(buffer, &amp;regbuf-&gt;rnode, &amp;regbuf-&gt;forkno, &amp;regbuf-&gt;block);</span><br><span class="line">regbuf-&gt;page = BufferGetPage(buffer);</span><br><span class="line">regbuf-&gt;flags = flags;</span><br><span class="line">regbuf-&gt;rdata_tail = (XLogRecData *) &amp;regbuf-&gt;rdata_head;</span><br><span class="line">regbuf-&gt;rdata_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓冲区标记为已使用</span></span><br><span class="line">regbuf-&gt;in_use = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="XLogRegisterBufData">XLogRegisterBufData</h4><p>函数主要作用是将元组内容注册到WAL记录中。需要参数block id，这个id必须是已经通过<code>XLogRegisterBuffer</code>注册的block</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取已经注册的缓冲区结构</span></span><br><span class="line">regbuf = &amp;registered_buffers[block_id];</span><br><span class="line"><span class="keyword">if</span> (!regbuf-&gt;in_use)</span><br><span class="line">    elog(ERROR, <span class="string">&quot;no block with id %d registered with WAL insertion&quot;</span>,</span><br><span class="line">         block_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取buffer数据</span></span><br><span class="line"><span class="keyword">if</span> (num_rdatas &gt;= max_rdatas)</span><br><span class="line">    elog(ERROR, <span class="string">&quot;too much WAL data&quot;</span>);</span><br><span class="line">rdata = &amp;rdatas[num_rdatas++];</span><br><span class="line"></span><br><span class="line">rdata-&gt;data = data;</span><br><span class="line">rdata-&gt;len = len;</span><br><span class="line"></span><br><span class="line">regbuf-&gt;rdata_tail-&gt;next = rdata;</span><br><span class="line">regbuf-&gt;rdata_tail = rdata;</span><br><span class="line">regbuf-&gt;rdata_len += len;</span><br></pre></td></tr></table></figure><h4 id="XLogInsert">XLogInsert</h4><p>插入WAL的操作由函数<code>XLogInsert</code>完成，根据Rdata链表和相应的资源管理器info向WAL日志文件中插入一条WAL记录。事务执行插入，删除，更新，提交，终止或回滚命令时都需要调用此函数</p><ul class="lvl-0"><li class="lvl-2"><p>判断调用时是否设置了rmgr标记位：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((info &amp; ~(XLR_RMGR_INFO_MASK |</span><br><span class="line">              XLR_SPECIAL_REL_UPDATE |</span><br><span class="line">              XLR_CHECK_CONSISTENCY)) != <span class="number">0</span>)</span><br><span class="line">    elog(PANIC, <span class="string">&quot;invalid xlog info mask %02X&quot;</span>, info);</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果处于bootstrap模式，除了XLog资源外，不需要实际记录内容，指向第一个检查点的指针</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsBootstrapProcessingMode() &amp;&amp; rmid != RM_XLog_ID)</span><br><span class="line">&#123;</span><br><span class="line">    XLogResetInsertion();</span><br><span class="line">    EndPos = SizeOfXLogLongPHD;</span><br><span class="line">    <span class="keyword">return</span> EndPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>组合成完整的WAL记录并写入WAL日志</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    XLogRecPtrRedoRecPtr;</span><br><span class="line">    <span class="type">bool</span>doPageWrites;</span><br><span class="line">    XLogRecPtrfpw_lsn;</span><br><span class="line">    XLogRecData *rdt;</span><br><span class="line"></span><br><span class="line">    GetFullPageWriteInfo(&amp;RedoRecPtr, &amp;doPageWrites);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数组装注册的数据</span></span><br><span class="line">    rdt = XLogRecordAssemble(rmid, info, RedoRecPtr, doPageWrites,</span><br><span class="line">                             &amp;fpw_lsn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将组装好的数据写入到WAL内存中</span></span><br><span class="line">    EndPos = XLogInsertRecord(rdt, fpw_lsn, curinsert_flags);</span><br><span class="line">&#125; <span class="keyword">while</span> (EndPos == InvalidXLogRecPtr);</span><br></pre></td></tr></table></figure><h4 id="XLogRecordAssemble">XLogRecordAssemble</h4><p>函数用于将已注册的数据和缓冲区页面数据组装成一条WAL记录，将其写入到<code>XLogRecData</code>链表中。</p><p>执行到这个阶段，wal记录的数据存储在：</p><ol><li class="lvl-3"><p>mainrdata_head</p></li><li class="lvl-3"><p>每一个注册的buff的rdata_head</p></li><li class="lvl-3"><p>每一个注册的buff的page字段中</p></li></ol><p>函数执行过程如下：</p><ul class="lvl-0"><li class="lvl-2"><p>保存头部信息</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">XLogRecData *rdt;<span class="comment">// XLogRecData链表指针</span></span><br><span class="line">uint32total_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>block_id;</span><br><span class="line">pg_crc32crdata_crc;</span><br><span class="line">registered_buffer *prev_regbuf = <span class="literal">NULL</span>;</span><br><span class="line">XLogRecData *rdt_datas_last;</span><br><span class="line">XLogRecord *rechdr;</span><br><span class="line"><span class="type">char</span>   *scratch = hdr_scratch;</span><br><span class="line"></span><br><span class="line">rechdr = (XLogRecord *) scratch;</span><br><span class="line">scratch += SizeOfXLogRecord;</span><br><span class="line"></span><br><span class="line">hdr_rdt.next = <span class="literal">NULL</span>;</span><br><span class="line">rdt_datas_last = &amp;hdr_rdt;</span><br><span class="line">hdr_rdt.data = hdr_scratch;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-3"><p>构造保存所有块公用的数据部分的rdata链</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">*fpw_lsn = InvalidXLogRecPtr;</span><br><span class="line"><span class="keyword">for</span> (block_id = <span class="number">0</span>; block_id &lt; max_registered_block_id; block_id++)</span><br><span class="line">&#123;</span><br><span class="line">    registered_buffer *regbuf = &amp;registered_buffers[block_id];</span><br><span class="line">    XLogRecordBlockHeader bkpb;</span><br><span class="line">    XLogRecordBlockImageHeader bimg;</span><br><span class="line">    XLogRecordBlockCompressHeader cbimg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">bool</span>samerel;</span><br><span class="line">    <span class="type">bool</span>is_compressed = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span>include_image;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置block头部信息</span></span><br><span class="line">    bkpb.id = block_id;</span><br><span class="line">    bkpb.fork_flags = regbuf-&gt;forkno;</span><br><span class="line">    bkpb.data_length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置标记位</span></span><br><span class="line">    <span class="keyword">if</span> ((regbuf-&gt;flags &amp; REGBUF_WILL_INIT) == REGBUF_WILL_INIT)</span><br><span class="line">        bkpb.fork_flags |= BKPBLOCK_WILL_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行full_page_write，写入XLogRecordBlockImageHeader</span></span><br><span class="line">    <span class="keyword">if</span> (include_image)</span><br><span class="line">    &#123;</span><br><span class="line">        Page        page = regbuf-&gt;page;<span class="comment">// 获取对应的page</span></span><br><span class="line">        uint16      compressed_len = <span class="number">0</span>;<span class="comment">// 压缩后的大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// page需要备份，计算空闲空间大小和偏移</span></span><br><span class="line">        <span class="comment">// &quot;hole&quot;指的是page中的空白区域</span></span><br><span class="line">        <span class="keyword">if</span> (regbuf-&gt;flags &amp; REGBUF_STANDARD)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果页面遵循标准布局，lower和upper指针将被跳过</span></span><br><span class="line">            uint16      lower = ((PageHeader) page)-&gt;pd_lower;<span class="comment">// 获取lower</span></span><br><span class="line">            uint16      upper = ((PageHeader) page)-&gt;pd_upper;<span class="comment">// 获取upper</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断page中是否存在&quot;hole&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (lower &gt;= SizeOfPageHeaderData &amp;&amp;</span><br><span class="line">                upper &gt; lower &amp;&amp;</span><br><span class="line">                upper &lt;= BLCKSZ)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 计算“hole”的长度的偏移量</span></span><br><span class="line">                bimg.hole_offset = lower;</span><br><span class="line">                cbimg.hole_length = upper - lower;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 没有可以移除的&quot;hole&quot;</span></span><br><span class="line">                bimg.hole_offset = <span class="number">0</span>;</span><br><span class="line">                cbimg.hole_length = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不是标准的页面布局，无法尝试估算&quot;hole&quot;</span></span><br><span class="line">            bimg.hole_offset = <span class="number">0</span>;</span><br><span class="line">            cbimg.hole_length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用WAL压缩</span></span><br><span class="line">        <span class="keyword">if</span> (wal_compression)</span><br><span class="line">        &#123;</span><br><span class="line">            is_compressed =</span><br><span class="line">                XLogCompressBackupBlock(page, bimg.hole_offset,</span><br><span class="line">                                        cbimg.hole_length,</span><br><span class="line">                                        regbuf-&gt;compressed_page,</span><br><span class="line">                                        &amp;compressed_len);<span class="comment">// 调用XLogCompressBackupBlock压缩</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充XLogRecordBlockHeader结构体的剩余字段</span></span><br><span class="line">        bkpb.fork_flags |= BKPBLOCK_HAS_IMAGE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为page内容构造XLogRecData入口</span></span><br><span class="line">        rdt_datas_last-&gt;next = &amp;regbuf-&gt;bkp_rdatas[<span class="number">0</span>];</span><br><span class="line">        rdt_datas_last = rdt_datas_last-&gt;next;</span><br><span class="line">        <span class="comment">// 设置标记</span></span><br><span class="line">        bimg.bimg_info = (cbimg.hole_length == <span class="number">0</span>) ? <span class="number">0</span> : BKPIMAGE_HAS_HOLE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在redo期间,在设置了BKPIMAGE_APPLY标记的情况下full-page才会回放.</span></span><br><span class="line">        <span class="keyword">if</span> (needs_backup)</span><br><span class="line">            bimg.bimg_info |= BKPIMAGE_APPLY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要压缩</span></span><br><span class="line">        <span class="keyword">if</span> (is_compressed)</span><br><span class="line">        &#123;</span><br><span class="line">            bimg.length = compressed_len;<span class="comment">// 压缩后的空间</span></span><br><span class="line">            bimg.bimg_info |= BKPIMAGE_IS_COMPRESSED;<span class="comment">// 压缩标记</span></span><br><span class="line"></span><br><span class="line">            rdt_datas_last-&gt;data = regbuf-&gt;compressed_page;<span class="comment">// 放在registered_buffer中</span></span><br><span class="line">            rdt_datas_last-&gt;len = compressed_len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有压缩，计算image的大小</span></span><br><span class="line">            bimg.length = BLCKSZ - cbimg.hole_length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果没有&quot;hole&quot;存在</span></span><br><span class="line">            <span class="keyword">if</span> (cbimg.hole_length == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rdt_datas_last-&gt;data = page;<span class="comment">// 数据指针直接指向page</span></span><br><span class="line">                rdt_datas_last-&gt;len = BLCKSZ;<span class="comment">// 大小为block size</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 跳过hole</span></span><br><span class="line">                rdt_datas_last-&gt;data = page;<span class="comment">// 数据指针</span></span><br><span class="line">                rdt_datas_last-&gt;len = bimg.hole_offset;<span class="comment">// 获取hole的偏移</span></span><br><span class="line"></span><br><span class="line">                rdt_datas_last-&gt;next = &amp;regbuf-&gt;bkp_rdatas[<span class="number">1</span>];<span class="comment">// 第2部分</span></span><br><span class="line">                rdt_datas_last = rdt_datas_last-&gt;next;</span><br><span class="line"></span><br><span class="line">                rdt_datas_last-&gt;data =</span><br><span class="line">                    page + (bimg.hole_offset + cbimg.hole_length);<span class="comment">// 指针指向第二部分</span></span><br><span class="line">                rdt_datas_last-&gt;len =</span><br><span class="line">                    BLCKSZ - (bimg.hole_offset + cbimg.hole_length);<span class="comment">// 设置长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        total_len += bimg.length;<span class="comment">// 调整总长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要包含数据</span></span><br><span class="line">    <span class="keyword">if</span> (needs_data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把该缓冲区链接到调用者提供的rdata链中，构成一个整体的链表</span></span><br><span class="line">        bkpb.fork_flags |= BKPBLOCK_HAS_DATA;</span><br><span class="line">        bkpb.data_length = regbuf-&gt;rdata_len;</span><br><span class="line">        total_len += regbuf-&gt;rdata_len;</span><br><span class="line"></span><br><span class="line">        rdt_datas_last-&gt;next = regbuf-&gt;rdata_head;</span><br><span class="line">        rdt_datas_last = regbuf-&gt;rdata_tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在上一个注册的buf，而且RefFileNode相同</span></span><br><span class="line">    <span class="keyword">if</span> (prev_regbuf &amp;&amp; RelFileNodeEquals(regbuf-&gt;rnode, prev_regbuf-&gt;rnode))</span><br><span class="line">    &#123;</span><br><span class="line">        samerel = <span class="literal">true</span>;</span><br><span class="line">        bkpb.fork_flags |= BKPBLOCK_SAME_REL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        samerel = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 切换为当前的注册的buf</span></span><br><span class="line">    prev_regbuf = regbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝头部信息到scratch缓冲区中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(scratch, &amp;bkpb, SizeOfXLogRecordBlockHeader);</span><br><span class="line">    scratch += SizeOfXLogRecordBlockHeader;</span><br><span class="line">    <span class="keyword">if</span> (include_image)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(scratch, &amp;bimg, SizeOfXLogRecordBlockImageHeader);</span><br><span class="line">        scratch += SizeOfXLogRecordBlockImageHeader;</span><br><span class="line">        <span class="comment">// 压缩存储,追加SizeOfXLogRecordBlockCompressHeader</span></span><br><span class="line">        <span class="keyword">if</span> (cbimg.hole_length != <span class="number">0</span> &amp;&amp; is_compressed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(scratch, &amp;cbimg,</span><br><span class="line">                   SizeOfXLogRecordBlockCompressHeader);</span><br><span class="line">            scratch += SizeOfXLogRecordBlockCompressHeader;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是同一个REL，追加RelFileNode</span></span><br><span class="line">    <span class="keyword">if</span> (!samerel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(scratch, &amp;regbuf-&gt;rnode, <span class="keyword">sizeof</span>(RelFileNode));</span><br><span class="line">        scratch += <span class="keyword">sizeof</span>(RelFileNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加BlockNumber</span></span><br><span class="line">    <span class="built_in">memcpy</span>(scratch, &amp;regbuf-&gt;block, <span class="keyword">sizeof</span>(BlockNumber));</span><br><span class="line">    scratch += <span class="keyword">sizeof</span>(BlockNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>接下来组装XLog Record origin标记</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((curinsert_flags &amp; XLog_INCLUDE_ORIGIN) &amp;&amp;</span><br><span class="line">    replorigin_session_origin != InvalidRepOriginId)</span><br><span class="line">&#123;</span><br><span class="line">    *(scratch++) = (<span class="type">char</span>) XLR_BLOCK_ID_ORIGIN;</span><br><span class="line">    <span class="built_in">memcpy</span>(scratch, &amp;replorigin_session_origin, <span class="keyword">sizeof</span>(replorigin_session_origin));</span><br><span class="line">    scratch += <span class="keyword">sizeof</span>(replorigin_session_origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>接下来组装数据（main data）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mainrdata_len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 长度超过255，则使用Long格式</span></span><br><span class="line">    <span class="keyword">if</span> (mainrdata_len &gt; <span class="number">255</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *(scratch++) = (<span class="type">char</span>) XLR_BLOCK_ID_DATA_LONG;</span><br><span class="line">        <span class="built_in">memcpy</span>(scratch, &amp;mainrdata_len, <span class="keyword">sizeof</span>(uint32));</span><br><span class="line">        scratch += <span class="keyword">sizeof</span>(uint32);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *(scratch++) = (<span class="type">char</span>) XLR_BLOCK_ID_DATA_SHORT;</span><br><span class="line">        *(scratch++) = (uint8) mainrdata_len;</span><br><span class="line">    &#125;</span><br><span class="line">    rdt_datas_last-&gt;next = mainrdata_head;</span><br><span class="line">    rdt_datas_last = mainrdata_last;</span><br><span class="line">    total_len += mainrdata_len;</span><br><span class="line">&#125;</span><br><span class="line">rdt_datas_last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">hdr_rdt.len = (scratch - hdr_scratch);<span class="comment">// 头部大小</span></span><br><span class="line">total_len += hdr_rdt.len;<span class="comment">// 总长度</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>计算数据的CRC</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INIT_CRC32C(rdata_crc);</span><br><span class="line">COMP_CRC32C(rdata_crc, hdr_scratch + SizeOfXLogRecord, hdr_rdt.len - SizeOfXLogRecord);</span><br><span class="line"><span class="keyword">for</span> (rdt = hdr_rdt.next; rdt != <span class="literal">NULL</span>; rdt = rdt-&gt;next)</span><br><span class="line">    COMP_CRC32C(rdata_crc, rdt-&gt;data, rdt-&gt;len);</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>最后填充记录头部信息的其他域字段</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rechdr-&gt;xl_xid = GetCurrentTransactionIdIfAny();</span><br><span class="line">rechdr-&gt;xl_tot_len = total_len;</span><br><span class="line">rechdr-&gt;xl_info = info;</span><br><span class="line">rechdr-&gt;xl_rmid = rmid;</span><br><span class="line">rechdr-&gt;xl_prev = InvalidXLogRecPtr;</span><br><span class="line">rechdr-&gt;xl_crc = rdata_crc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;hdr_rdt;</span><br></pre></td></tr></table></figure><h4 id="XLogInsertRecord">XLogInsertRecord</h4><p>将<code>XLogRecordAssemble</code>组装好的记录插入到WAL内存中。过程分两步：</p><ul class="lvl-0"><li class="lvl-2"><p>在内存中为WAL记录保留足够的空间</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isLogSwitch)</span><br><span class="line">    inserted = ReserveXLogSwitch(&amp;StartPos, &amp;EndPos, &amp;rechdr-&gt;xl_prev);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ReserveXLogInsertLocation(rechdr-&gt;xl_tot_len, &amp;StartPos, &amp;EndPos,</span><br><span class="line">                              &amp;rechdr-&gt;xl_prev);</span><br><span class="line">    inserted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将记录复制到WAL内存中</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inserted)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算头部的CRC</span></span><br><span class="line">    rdata_crc = rechdr-&gt;xl_crc;</span><br><span class="line">    COMP_CRC32C(rdata_crc, rechdr, offsetof(XLogRecord, xl_crc));</span><br><span class="line">    FIN_CRC32C(rdata_crc);</span><br><span class="line">    rechdr-&gt;xl_crc = rdata_crc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的数据，包括header信息，均可以进行插入</span></span><br><span class="line">    CopyXLogRecordToWAL(rechdr-&gt;xl_tot_len, isLogSwitch, rdata,</span><br><span class="line">                        StartPos, EndPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新最后一条重要记录的LSN，当持有锁时，只更新第一个</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; XLog_MARK_UNIMPORTANT) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>lockno = holdingAllLocks ? <span class="number">0</span> : MyLockNo;</span><br><span class="line"></span><br><span class="line">        WALInsertLocks[lockno].l.lastImportantAt = StartPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PageSetLSN">PageSetLSN</h4><p>更新被修改的Page LSN</p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Postgresql 使用 wal 日志保存每一次的数据修改，这样保证了数据库即使意外宕机，也能利用它准确的恢复数据。wal 日志也叫做 xlog，在 9.4 版本之后作了重大更新，本篇只讲解最新版的格式。wal 日志被用于多个方面，比如修改数据，修改索引等，每种用途的格式</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/categories/PostgreSQL/"/>
    
    
    <category term="PostgreSQL" scheme="https://spike1337.github.io/tags/PostgreSQL/"/>
    
    <category term="replication" scheme="https://spike1337.github.io/tags/replication/"/>
    
    <category term="WAL" scheme="https://spike1337.github.io/tags/WAL/"/>
    
  </entry>
  
</feed>
